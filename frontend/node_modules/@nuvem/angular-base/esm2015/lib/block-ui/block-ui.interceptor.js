import { __decorate } from "tslib";
import { HttpResponse } from '@angular/common/http';
import { Injectable } from "@angular/core";
import { tap } from 'rxjs/operators';
import { BlockUiService } from './block-ui.service';
import * as i0 from "@angular/core";
import * as i1 from "./block-ui.service";
/**
 * Class BlockUiInterceptor
 * @class
 */
let BlockUiInterceptor = class BlockUiInterceptor {
    /**
     * constructor method
     * @constructor
     * @param {BlockUiService} service
     */
    constructor(service) {
        this.service = service;
    }
    /**
     * intercept method
     * @public
     * @param {HttpRequest<any>} req
     * @param {HttpHandler} next
     * @return Observable<HttpEvent<any>>
     */
    intercept(req, next) {
        if (this.isMutation(req.method)) {
            this.service.show();
        }
        return next.handle(req).pipe(tap((event) => {
            if (event instanceof HttpResponse) {
                this.service.hide();
            }
        }, (err) => {
            this.service.hide();
        }));
    }
    /**
     * isMutation method
     * @private
     * @param {string} method
     * @return boolean
     */
    isMutation(method) {
        const mutationsMethods = [
            'DELETE',
            'PATCH',
            'POST',
            'PUT'
        ];
        return mutationsMethods.indexOf(method) !== -1;
    }
};
BlockUiInterceptor.ctorParameters = () => [
    { type: BlockUiService }
];
BlockUiInterceptor.ɵprov = i0.ɵɵdefineInjectable({ factory: function BlockUiInterceptor_Factory() { return new BlockUiInterceptor(i0.ɵɵinject(i1.BlockUiService)); }, token: BlockUiInterceptor, providedIn: "root" });
BlockUiInterceptor = __decorate([
    Injectable({
        providedIn: 'root'
    })
], BlockUiInterceptor);
export { BlockUiInterceptor };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmxvY2stdWkuaW50ZXJjZXB0b3IuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AbnV2ZW0vYW5ndWxhci1iYXNlLyIsInNvdXJjZXMiOlsibGliL2Jsb2NrLXVpL2Jsb2NrLXVpLmludGVyY2VwdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQSxPQUFPLEVBQXVDLFlBQVksRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRXpGLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JDLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQzs7O0FBRXBEOzs7R0FHRztBQUlILElBQWEsa0JBQWtCLEdBQS9CLE1BQWEsa0JBQWtCO0lBRTNCOzs7O09BSUc7SUFDSCxZQUFvQixPQUF1QjtRQUF2QixZQUFPLEdBQVAsT0FBTyxDQUFnQjtJQUFHLENBQUM7SUFFL0M7Ozs7OztPQU1HO0lBQ0gsU0FBUyxDQUFDLEdBQXFCLEVBQUUsSUFBaUI7UUFFOUMsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUM3QixJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDO1NBQ3ZCO1FBRUQsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FDeEIsR0FBRyxDQUNDLENBQUMsS0FBcUIsRUFBRSxFQUFFO1lBQ3RCLElBQUksS0FBSyxZQUFZLFlBQVksRUFBRTtnQkFDL0IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQzthQUN2QjtRQUNMLENBQUMsRUFDRCxDQUFDLEdBQVEsRUFBRSxFQUFFO1lBQ1QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUN4QixDQUFDLENBQ0osQ0FDSixDQUFDO0lBQ04sQ0FBQztJQUNEOzs7OztPQUtHO0lBQ0ssVUFBVSxDQUFDLE1BQWM7UUFDN0IsTUFBTSxnQkFBZ0IsR0FBRztZQUNyQixRQUFRO1lBQ1IsT0FBTztZQUNQLE1BQU07WUFDTixLQUFLO1NBQ1IsQ0FBQztRQUVGLE9BQU8sZ0JBQWdCLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ25ELENBQUM7Q0FDSixDQUFBOztZQTVDZ0MsY0FBYzs7O0FBUGxDLGtCQUFrQjtJQUg5QixVQUFVLENBQUM7UUFDUixVQUFVLEVBQUUsTUFBTTtLQUNyQixDQUFDO0dBQ1csa0JBQWtCLENBbUQ5QjtTQW5EWSxrQkFBa0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBIdHRwRXZlbnQsIEh0dHBIYW5kbGVyLCBIdHRwUmVxdWVzdCwgSHR0cFJlc3BvbnNlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0IHsgSHR0cEludGVyY2VwdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBCbG9ja1VpU2VydmljZSB9IGZyb20gJy4vYmxvY2stdWkuc2VydmljZSc7XG5cbi8qKlxuICogQ2xhc3MgQmxvY2tVaUludGVyY2VwdG9yXG4gKiBAY2xhc3NcbiAqL1xuQEluamVjdGFibGUoe1xuICAgIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBCbG9ja1VpSW50ZXJjZXB0b3IgaW1wbGVtZW50cyBIdHRwSW50ZXJjZXB0b3Ige1xuXG4gICAgLyoqXG4gICAgICogY29uc3RydWN0b3IgbWV0aG9kXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtCbG9ja1VpU2VydmljZX0gc2VydmljZSBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHNlcnZpY2U6IEJsb2NrVWlTZXJ2aWNlKSB7fVxuXG4gICAgLyoqXG4gICAgICogaW50ZXJjZXB0IG1ldGhvZFxuICAgICAqIEBwdWJsaWMgXG4gICAgICogQHBhcmFtIHtIdHRwUmVxdWVzdDxhbnk+fSByZXFcbiAgICAgKiBAcGFyYW0ge0h0dHBIYW5kbGVyfSBuZXh0XG4gICAgICogQHJldHVybiBPYnNlcnZhYmxlPEh0dHBFdmVudDxhbnk+PlxuICAgICAqL1xuICAgIGludGVyY2VwdChyZXE6IEh0dHBSZXF1ZXN0PGFueT4sIG5leHQ6IEh0dHBIYW5kbGVyKTogT2JzZXJ2YWJsZTxIdHRwRXZlbnQ8YW55Pj4ge1xuXG4gICAgICAgIGlmICh0aGlzLmlzTXV0YXRpb24ocmVxLm1ldGhvZCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2VydmljZS5zaG93KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV4dC5oYW5kbGUocmVxKS5waXBlKFxuICAgICAgICAgICAgdGFwKFxuICAgICAgICAgICAgICAgIChldmVudDogSHR0cEV2ZW50PGFueT4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgSHR0cFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlcnZpY2UuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAoZXJyOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXJ2aWNlLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGlzTXV0YXRpb24gbWV0aG9kXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG4gICAgICogQHJldHVybiBib29sZWFuXG4gICAgICovXG4gICAgcHJpdmF0ZSBpc011dGF0aW9uKG1ldGhvZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uc01ldGhvZHMgPSBbXG4gICAgICAgICAgICAnREVMRVRFJyxcbiAgICAgICAgICAgICdQQVRDSCcsXG4gICAgICAgICAgICAnUE9TVCcsXG4gICAgICAgICAgICAnUFVUJ1xuICAgICAgICBdO1xuXG4gICAgICAgIHJldHVybiBtdXRhdGlvbnNNZXRob2RzLmluZGV4T2YobWV0aG9kKSAhPT0gLTE7XG4gICAgfVxufVxuIl19