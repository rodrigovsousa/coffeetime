import { __decorate, __param } from "tslib";
import { ErrorHandler, Inject, Injectable } from '@angular/core';
import { ErrorProvider } from './providers/error.provider';
import * as i0 from "@angular/core";
import * as i1 from "./providers/error.provider";
/**
 * Class ErrorService
 * @class
 */
let ErrorService = class ErrorService extends ErrorHandler {
    /**
     * Metodo construtor responável por injetar o serviço ErrorProvider
     * @param {ErrorProvider} providers
     */
    constructor(providers) {
        super();
        this.providers = providers;
    }
    /**
     * Metodo responsável por idetificar e obter os erros lançados de requisições http/https
     * @param {Error} error
     * @returns void
     */
    handleError(error) {
        try {
            this.providers.forEach(p => {
                if (p.shouldHandle(error)) {
                    p.handle(error);
                }
            });
        }
        catch (e) {
        }
        super.handleError(error);
    }
};
ErrorService.ctorParameters = () => [
    { type: Array, decorators: [{ type: Inject, args: [ErrorProvider,] }] }
];
ErrorService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ErrorService_Factory() { return new ErrorService(i0.ɵɵinject(i1.ErrorProvider)); }, token: ErrorService, providedIn: "root" });
ErrorService = __decorate([
    Injectable({
        providedIn: 'root',
    }),
    __param(0, Inject(ErrorProvider))
], ErrorService);
export { ErrorService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXJyb3Iuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BudXZlbS9hbmd1bGFyLWJhc2UvIiwic291cmNlcyI6WyJsaWIvZXJyb3IvZXJyb3Iuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2pFLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQzs7O0FBRTNEOzs7R0FHRztBQUlILElBQWEsWUFBWSxHQUF6QixNQUFhLFlBQWEsU0FBUSxZQUFZO0lBRTFDOzs7T0FHRztJQUNILFlBQTJDLFNBQTBCO1FBQ2pFLEtBQUssRUFBRSxDQUFDO1FBRCtCLGNBQVMsR0FBVCxTQUFTLENBQWlCO0lBRXJFLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsV0FBVyxDQUFDLEtBQVk7UUFDcEIsSUFBSTtZQUNBLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUN2QixJQUFJLENBQUMsQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLEVBQUU7b0JBQ3ZCLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7aUJBQ25CO1lBQ0wsQ0FBQyxDQUFDLENBQUM7U0FDTjtRQUFDLE9BQU8sQ0FBQyxFQUFFO1NBQ1g7UUFDRCxLQUFLLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzdCLENBQUM7Q0FDSixDQUFBOzt3Q0FwQmdCLE1BQU0sU0FBQyxhQUFhOzs7QUFOeEIsWUFBWTtJQUh4QixVQUFVLENBQUM7UUFDUixVQUFVLEVBQUUsTUFBTTtLQUNyQixDQUFDO0lBT2UsV0FBQSxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUE7R0FOekIsWUFBWSxDQTBCeEI7U0ExQlksWUFBWSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVycm9ySGFuZGxlciwgSW5qZWN0LCBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBFcnJvclByb3ZpZGVyIH0gZnJvbSAnLi9wcm92aWRlcnMvZXJyb3IucHJvdmlkZXInO1xuXG4vKipcbiAqIENsYXNzIEVycm9yU2VydmljZVxuICogQGNsYXNzXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIEVycm9yU2VydmljZSBleHRlbmRzIEVycm9ySGFuZGxlciB7XG5cbiAgICAvKipcbiAgICAgKiBNZXRvZG8gY29uc3RydXRvciByZXNwb27DoXZlbCBwb3IgaW5qZXRhciBvIHNlcnZpw6dvIEVycm9yUHJvdmlkZXJcbiAgICAgKiBAcGFyYW0ge0Vycm9yUHJvdmlkZXJ9IHByb3ZpZGVyc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKEBJbmplY3QoRXJyb3JQcm92aWRlcikgcHJpdmF0ZSBwcm92aWRlcnM6IEVycm9yUHJvdmlkZXJbXSkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldG9kbyByZXNwb25zw6F2ZWwgcG9yIGlkZXRpZmljYXIgZSBvYnRlciBvcyBlcnJvcyBsYW7Dp2Fkb3MgZGUgcmVxdWlzacOnw7VlcyBodHRwL2h0dHBzXG4gICAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3JcbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgaGFuZGxlRXJyb3IoZXJyb3I6IEVycm9yKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVycy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwLnNob3VsZEhhbmRsZShlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcC5oYW5kbGUoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgIH1cbn1cbiJdfQ==