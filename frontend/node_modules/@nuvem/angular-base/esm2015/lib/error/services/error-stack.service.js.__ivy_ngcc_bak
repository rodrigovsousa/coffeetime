import { __decorate } from "tslib";
import { Injectable } from '@angular/core';
import { ReplaySubject } from 'rxjs';
import { HttpGenericErrorService } from '../services/http-generic-error.service';
import * as i0 from "@angular/core";
import * as i1 from "./http-generic-error.service";
/**
 * Serviço de erros ErrorStackService
 * @class
 */
let ErrorStackService = class ErrorStackService {
    /**
     * metodo construtor injeta serviço generico de erros
     * @param {HttpGenericErrorService} genericErrorService
     * @constructor
     */
    constructor(genericErrorService) {
        this.genericErrorService = genericErrorService;
        /**
         * Propriedade errors
         * @type {ReplaySubject<NamedErrorType>}
         */
        this.errors = new ReplaySubject();
        if (null === localStorage.getItem('errorStack')) {
            localStorage.setItem('errorStack', JSON.stringify([]));
        }
        this.getErrorsSubjects().forEach((error) => {
            this.errors.next(error);
        });
    }
    /**
     * Metodo responsável por criar erro do tipo HttpResponse
     * @param {HttpErrorResponse} error
     * @returns void
     */
    create(error) {
        const namedError = this.createNamedError(error);
        const persistedErrors = this.getErrorsSubjects();
        if (persistedErrors.length >= 15) {
            persistedErrors.shift();
        }
        persistedErrors.push(namedError);
        localStorage.setItem('errorStack', JSON.stringify(persistedErrors));
        this.errors.next(namedError);
    }
    /**
     * Metodo responsável por obter o conteúdo dos erros emitidos
     * @private
     * @returns NamedErrorType[]
     */
    getErrorsSubjects() {
        return JSON.parse(localStorage.getItem('errorStack'));
    }
    /**
     * Metodo responsável por itentifica o tipo de erro lançado
     * @private
     * @param {HttpErrorResponse} error
     * @returns NamedErrorType
     */
    createNamedError(error) {
        let fullMessage;
        let namedError;
        let createdAt = new Date();
        let errorId = this.getErrorId(error);
        let title;
        if (error.headers.get('Content-Type') === 'application/problem+json') {
            fullMessage = `X-Correlation-ID: ${errorId}
                           createdAt: ${createdAt}
                           status: ${error.status}
                           url: ${error.url}
                           body: ${error.error.detail}
                           stacktrace: ${error.error.stacktrace}
                           cause: ${error.error.cause}`;
            title = error.error.title;
        }
        else {
            const genericError = this.genericErrorService.getErrorByCode(error);
            fullMessage = `X-Correlation-ID: ${errorId}
                           createdAt: ${createdAt}
                           status: ${error.status}
                           url: ${error.url}
                           body: ${genericError.detail}`;
            title = genericError.title;
        }
        namedError = {
            message: title,
            createdAt: createdAt,
            correlationId: errorId,
            fullMessage: fullMessage
        };
        return namedError;
    }
    /**
     * Metodo responsável por obter o identificador do erro
     * @private
     * @param {HttpErrorResponse} error
     * @returns string
     */
    getErrorId(error) {
        let errorKey;
        error.headers.keys().every(key => {
            if (key.toUpperCase() === 'X-CORRELATION-ID') {
                errorKey = key;
                return false;
            }
            return true;
        });
        return errorKey ? error.headers.get(errorKey) : null;
    }
};
ErrorStackService.ctorParameters = () => [
    { type: HttpGenericErrorService }
];
ErrorStackService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ErrorStackService_Factory() { return new ErrorStackService(i0.ɵɵinject(i1.HttpGenericErrorService)); }, token: ErrorStackService, providedIn: "root" });
ErrorStackService = __decorate([
    Injectable({
        providedIn: 'root',
    })
], ErrorStackService);
export { ErrorStackService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXJyb3Itc3RhY2suc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BudXZlbS9hbmd1bGFyLWJhc2UvIiwic291cmNlcyI6WyJsaWIvZXJyb3Ivc2VydmljZXMvZXJyb3Itc3RhY2suc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBR3JDLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLHdDQUF3QyxDQUFDOzs7QUFFakY7OztHQUdHO0FBSUgsSUFBYSxpQkFBaUIsR0FBOUIsTUFBYSxpQkFBaUI7SUFRMUI7Ozs7T0FJRztJQUNILFlBQW9CLG1CQUE0QztRQUE1Qyx3QkFBbUIsR0FBbkIsbUJBQW1CLENBQXlCO1FBWGhFOzs7V0FHRztRQUNILFdBQU0sR0FBa0MsSUFBSSxhQUFhLEVBQWtCLENBQUM7UUFReEUsSUFBSSxJQUFJLEtBQUssWUFBWSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsRUFBRTtZQUM3QyxZQUFZLENBQUMsT0FBTyxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDMUQ7UUFFRCxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFxQixFQUFFLEVBQUU7WUFDdkQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDNUIsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILE1BQU0sQ0FBQyxLQUF3QjtRQUMzQixNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFaEQsTUFBTSxlQUFlLEdBQXFCLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBRW5FLElBQUksZUFBZSxDQUFDLE1BQU0sSUFBSSxFQUFFLEVBQUU7WUFDOUIsZUFBZSxDQUFDLEtBQUssRUFBRSxDQUFDO1NBQzNCO1FBRUQsZUFBZSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUVqQyxZQUFZLENBQUMsT0FBTyxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUM7UUFFcEUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDakMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSyxpQkFBaUI7UUFDckIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztJQUMxRCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSyxnQkFBZ0IsQ0FBQyxLQUF3QjtRQUM3QyxJQUFJLFdBQW1CLENBQUM7UUFDeEIsSUFBSSxVQUEwQixDQUFDO1FBQy9CLElBQUksU0FBUyxHQUFTLElBQUksSUFBSSxFQUFFLENBQUM7UUFDakMsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNyQyxJQUFJLEtBQW9CLENBQUM7UUFFekIsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsS0FBSywwQkFBMEIsRUFBRTtZQUNsRSxXQUFXLEdBQUcscUJBQXFCLE9BQU87d0NBQ2QsU0FBUztxQ0FDWixLQUFLLENBQUMsTUFBTTtrQ0FDZixLQUFLLENBQUMsR0FBRzttQ0FDUixLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU07eUNBQ1osS0FBSyxDQUFDLEtBQUssQ0FBQyxVQUFVO29DQUMzQixLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDO1lBRTVDLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztTQUU3QjthQUFNO1lBQ0gsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUVwRSxXQUFXLEdBQUcscUJBQXFCLE9BQU87d0NBQ2QsU0FBUztxQ0FDWixLQUFLLENBQUMsTUFBTTtrQ0FDZixLQUFLLENBQUMsR0FBRzttQ0FDUixZQUFZLENBQUMsTUFBTSxFQUFFLENBQUM7WUFFN0MsS0FBSyxHQUFHLFlBQVksQ0FBQyxLQUFLLENBQUM7U0FDOUI7UUFFRCxVQUFVLEdBQUc7WUFDVCxPQUFPLEVBQUUsS0FBSztZQUNkLFNBQVMsRUFBRSxTQUFTO1lBQ3BCLGFBQWEsRUFBRSxPQUFPO1lBQ3RCLFdBQVcsRUFBRSxXQUFXO1NBQzNCLENBQUM7UUFFRixPQUFPLFVBQVUsQ0FBQztJQUN0QixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSyxVQUFVLENBQUMsS0FBd0I7UUFDdkMsSUFBSSxRQUF1QixDQUFDO1FBRTVCLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQzdCLElBQUksR0FBRyxDQUFDLFdBQVcsRUFBRSxLQUFLLGtCQUFrQixFQUFFO2dCQUMxQyxRQUFRLEdBQUcsR0FBRyxDQUFDO2dCQUNmLE9BQU8sS0FBSyxDQUFDO2FBQ2hCO1lBQ0QsT0FBTyxJQUFJLENBQUM7UUFDaEIsQ0FBQyxDQUFDLENBQUM7UUFFSCxPQUFPLFFBQVEsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztJQUN6RCxDQUFDO0NBRUosQ0FBQTs7WUExRzRDLHVCQUF1Qjs7O0FBYnZELGlCQUFpQjtJQUg3QixVQUFVLENBQUM7UUFDUixVQUFVLEVBQUUsTUFBTTtLQUNyQixDQUFDO0dBQ1csaUJBQWlCLENBdUg3QjtTQXZIWSxpQkFBaUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSZXBsYXlTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBOYW1lZEVycm9yVHlwZSB9IGZyb20gJy4uL3R5cGVzL25hbWVkLWVycm9yLnR5cGUnO1xuaW1wb3J0IHsgSHR0cEVycm9yUmVzcG9uc2UgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgeyBIdHRwR2VuZXJpY0Vycm9yU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2h0dHAtZ2VuZXJpYy1lcnJvci5zZXJ2aWNlJztcblxuLyoqXG4gKiBTZXJ2acOnbyBkZSBlcnJvcyBFcnJvclN0YWNrU2VydmljZVxuICogQGNsYXNzIFxuICovXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBFcnJvclN0YWNrU2VydmljZSB7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wcmllZGFkZSBlcnJvcnNcbiAgICAgKiBAdHlwZSB7UmVwbGF5U3ViamVjdDxOYW1lZEVycm9yVHlwZT59XG4gICAgICovXG4gICAgZXJyb3JzOiBSZXBsYXlTdWJqZWN0PE5hbWVkRXJyb3JUeXBlPiA9IG5ldyBSZXBsYXlTdWJqZWN0PE5hbWVkRXJyb3JUeXBlPigpO1xuXG4gICAgLyoqXG4gICAgICogbWV0b2RvIGNvbnN0cnV0b3IgaW5qZXRhIHNlcnZpw6dvIGdlbmVyaWNvIGRlIGVycm9zXG4gICAgICogQHBhcmFtIHtIdHRwR2VuZXJpY0Vycm9yU2VydmljZX0gZ2VuZXJpY0Vycm9yU2VydmljZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZ2VuZXJpY0Vycm9yU2VydmljZTogSHR0cEdlbmVyaWNFcnJvclNlcnZpY2UpIHtcbiAgICAgICAgaWYgKG51bGwgPT09IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdlcnJvclN0YWNrJykpIHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdlcnJvclN0YWNrJywgSlNPTi5zdHJpbmdpZnkoW10pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ2V0RXJyb3JzU3ViamVjdHMoKS5mb3JFYWNoKChlcnJvcjogTmFtZWRFcnJvclR5cGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLm5leHQoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRvZG8gcmVzcG9uc8OhdmVsIHBvciBjcmlhciBlcnJvIGRvIHRpcG8gSHR0cFJlc3BvbnNlXG4gICAgICogQHBhcmFtIHtIdHRwRXJyb3JSZXNwb25zZX0gZXJyb3JcbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgY3JlYXRlKGVycm9yOiBIdHRwRXJyb3JSZXNwb25zZSkge1xuICAgICAgICBjb25zdCBuYW1lZEVycm9yID0gdGhpcy5jcmVhdGVOYW1lZEVycm9yKGVycm9yKTtcblxuICAgICAgICBjb25zdCBwZXJzaXN0ZWRFcnJvcnM6IE5hbWVkRXJyb3JUeXBlW10gPSB0aGlzLmdldEVycm9yc1N1YmplY3RzKCk7XG5cbiAgICAgICAgaWYgKHBlcnNpc3RlZEVycm9ycy5sZW5ndGggPj0gMTUpIHtcbiAgICAgICAgICAgIHBlcnNpc3RlZEVycm9ycy5zaGlmdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGVyc2lzdGVkRXJyb3JzLnB1c2gobmFtZWRFcnJvcik7XG5cbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2Vycm9yU3RhY2snLCBKU09OLnN0cmluZ2lmeShwZXJzaXN0ZWRFcnJvcnMpKTtcblxuICAgICAgICB0aGlzLmVycm9ycy5uZXh0KG5hbWVkRXJyb3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldG9kbyByZXNwb25zw6F2ZWwgcG9yIG9idGVyIG8gY29udGXDumRvIGRvcyBlcnJvcyBlbWl0aWRvc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMgTmFtZWRFcnJvclR5cGVbXVxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0RXJyb3JzU3ViamVjdHMoKTogTmFtZWRFcnJvclR5cGVbXSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdlcnJvclN0YWNrJykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldG9kbyByZXNwb25zw6F2ZWwgcG9yIGl0ZW50aWZpY2EgbyB0aXBvIGRlIGVycm8gbGFuw6dhZG9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SHR0cEVycm9yUmVzcG9uc2V9IGVycm9yXG4gICAgICogQHJldHVybnMgTmFtZWRFcnJvclR5cGVcbiAgICAgKi9cbiAgICBwcml2YXRlIGNyZWF0ZU5hbWVkRXJyb3IoZXJyb3I6IEh0dHBFcnJvclJlc3BvbnNlKTogTmFtZWRFcnJvclR5cGUge1xuICAgICAgICBsZXQgZnVsbE1lc3NhZ2U6IHN0cmluZztcbiAgICAgICAgbGV0IG5hbWVkRXJyb3I6IE5hbWVkRXJyb3JUeXBlO1xuICAgICAgICBsZXQgY3JlYXRlZEF0OiBEYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgbGV0IGVycm9ySWQgPSB0aGlzLmdldEVycm9ySWQoZXJyb3IpO1xuICAgICAgICBsZXQgdGl0bGU6IHN0cmluZyB8IG51bGw7XG5cbiAgICAgICAgaWYgKGVycm9yLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSA9PT0gJ2FwcGxpY2F0aW9uL3Byb2JsZW0ranNvbicpIHtcbiAgICAgICAgICAgIGZ1bGxNZXNzYWdlID0gYFgtQ29ycmVsYXRpb24tSUQ6ICR7ZXJyb3JJZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRBdDogJHtjcmVhdGVkQXR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6ICR7ZXJyb3Iuc3RhdHVzfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAke2Vycm9yLnVybH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6ICR7ZXJyb3IuZXJyb3IuZGV0YWlsfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2t0cmFjZTogJHtlcnJvci5lcnJvci5zdGFja3RyYWNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F1c2U6ICR7ZXJyb3IuZXJyb3IuY2F1c2V9YDtcblxuICAgICAgICAgICAgdGl0bGUgPSBlcnJvci5lcnJvci50aXRsZTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZ2VuZXJpY0Vycm9yID0gdGhpcy5nZW5lcmljRXJyb3JTZXJ2aWNlLmdldEVycm9yQnlDb2RlKGVycm9yKTtcblxuICAgICAgICAgICAgZnVsbE1lc3NhZ2UgPSBgWC1Db3JyZWxhdGlvbi1JRDogJHtlcnJvcklkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlZEF0OiAke2NyZWF0ZWRBdH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogJHtlcnJvci5zdGF0dXN9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICR7ZXJyb3IudXJsfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogJHtnZW5lcmljRXJyb3IuZGV0YWlsfWA7XG5cbiAgICAgICAgICAgIHRpdGxlID0gZ2VuZXJpY0Vycm9yLnRpdGxlO1xuICAgICAgICB9XG5cbiAgICAgICAgbmFtZWRFcnJvciA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IHRpdGxlLFxuICAgICAgICAgICAgY3JlYXRlZEF0OiBjcmVhdGVkQXQsXG4gICAgICAgICAgICBjb3JyZWxhdGlvbklkOiBlcnJvcklkLFxuICAgICAgICAgICAgZnVsbE1lc3NhZ2U6IGZ1bGxNZXNzYWdlXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5hbWVkRXJyb3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0b2RvIHJlc3BvbnPDoXZlbCBwb3Igb2J0ZXIgbyBpZGVudGlmaWNhZG9yIGRvIGVycm9cbiAgICAgKiBAcHJpdmF0ZSBcbiAgICAgKiBAcGFyYW0ge0h0dHBFcnJvclJlc3BvbnNlfSBlcnJvclxuICAgICAqIEByZXR1cm5zIHN0cmluZ1xuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0RXJyb3JJZChlcnJvcjogSHR0cEVycm9yUmVzcG9uc2UpOiBzdHJpbmcge1xuICAgICAgICBsZXQgZXJyb3JLZXk6IHN0cmluZyB8IG51bGw7XG5cbiAgICAgICAgZXJyb3IuaGVhZGVycy5rZXlzKCkuZXZlcnkoa2V5ID0+IHtcbiAgICAgICAgICAgIGlmIChrZXkudG9VcHBlckNhc2UoKSA9PT0gJ1gtQ09SUkVMQVRJT04tSUQnKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JLZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBlcnJvcktleSA/IGVycm9yLmhlYWRlcnMuZ2V0KGVycm9yS2V5KSA6IG51bGw7XG4gICAgfVxuXG59XG4iXX0=