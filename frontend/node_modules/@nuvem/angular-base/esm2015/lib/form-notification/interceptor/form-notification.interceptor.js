import { __decorate } from "tslib";
import { Injectable } from "@angular/core";
import { FormNotificationService } from "../services/form-notification.service";
import { CleanFormNotification } from "../types/clean-form-notification.type";
import * as i0 from "@angular/core";
import * as i1 from "../services/form-notification.service";
/**
 * Implementação de classe para interceptar e tratar requisições http/https
 * @class
 */
import * as ɵngcc0 from '@angular/core';
let FormNotificationInterceptor = class FormNotificationInterceptor {
    /**
     * Método construtor
     * @constructor
     * @param {AbstractAuthentication} auth
     */
    constructor(formNotificationService) {
        this.formNotificationService = formNotificationService;
    }
    /**
     * Método responsável por interceptar requisições HTTP/HTTPS
     * @public
     * @param {HttpRequest<any>} request
     * @param {HttpHandler} next
     * @returns Observable<HttpEvent<any>>
     */
    intercept(request, next) {
        this.formNotificationService
            .notify(new CleanFormNotification(request.url));
        return next.handle(request);
    }
};
FormNotificationInterceptor.ɵfac = function FormNotificationInterceptor_Factory(t) { return new (t || FormNotificationInterceptor)(ɵngcc0.ɵɵinject(FormNotificationService)); };
FormNotificationInterceptor.ctorParameters = () => [
    { type: FormNotificationService }
];
FormNotificationInterceptor.ɵprov = i0.ɵɵdefineInjectable({ factory: function FormNotificationInterceptor_Factory() { return new FormNotificationInterceptor(i0.ɵɵinject(i1.FormNotificationService)); }, token: FormNotificationInterceptor, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FormNotificationInterceptor, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: FormNotificationService }]; }, null); })();
export { FormNotificationInterceptor };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9ybS1ub3RpZmljYXRpb24uaW50ZXJjZXB0b3IuanMiLCJzb3VyY2VzIjpbIm5nOi9AbnV2ZW0vYW5ndWxhci1iYXNlL2xpYi9mb3JtLW5vdGlmaWNhdGlvbi9pbnRlcmNlcHRvci9mb3JtLW5vdGlmaWNhdGlvbi5pbnRlcmNlcHRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBUUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUUzQyxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSx1Q0FBdUMsQ0FBQztBQUNoRixPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSx1Q0FBdUMsQ0FBQztBQUM5RTtBQUVnQztBQURoQztBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUlILElBQWEsMkJBQTJCLEdBQXhDLE1BQWEsMkJBQTJCO0FBQUcsSUFFdkM7QUFDSjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsSUFBSSxZQUFvQix1QkFBZ0Q7QUFBSSxRQUFwRCw0QkFBdUIsR0FBdkIsdUJBQXVCLENBQXlCO0FBQUMsSUFBRSxDQUFDO0FBQzVFLElBQ0k7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLElBQUksU0FBUyxDQUFDLE9BQXlCLEVBQUUsSUFBaUI7QUFBSSxRQUN0RCxJQUFJLENBQUMsdUJBQXVCO0FBQ3BDLGFBQWEsTUFBTSxDQUFDLElBQUkscUJBQXFCLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDNUQsUUFBUSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDcEMsSUFBSSxDQUFDO0FBQ0wsQ0FDQztnTEFBQTtBQUNEO0FBQXFELFlBaEJKLHVCQUF1QjtBQUFHO0FBRTNFO0FBVGEsMkJBQTJCLG9CQUh2QyxVQUFVLENBQUMsVUFDUixVQUFVLEVBQUU7QUFBTSxPQUNyQixDQUFDLElBQ1c7YUFBMkIsQ0FzQnZDOzs7aUZBQ0Q7QUFBQyxTQXZCWSwyQkFBMkI7QUFBSSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgSHR0cEV2ZW50LFxuICAgIEh0dHBIYW5kbGVyLFxuICAgIEh0dHBJbnRlcmNlcHRvcixcbiAgICBIdHRwUmVxdWVzdFxufSBmcm9tIFwiQGFuZ3VsYXIvY29tbW9uL2h0dHBcIjtcblxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gXCJyeGpzXCI7XG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcblxuaW1wb3J0IHsgRm9ybU5vdGlmaWNhdGlvblNlcnZpY2UgfSBmcm9tIFwiLi4vc2VydmljZXMvZm9ybS1ub3RpZmljYXRpb24uc2VydmljZVwiO1xuaW1wb3J0IHsgQ2xlYW5Gb3JtTm90aWZpY2F0aW9uIH0gZnJvbSBcIi4uL3R5cGVzL2NsZWFuLWZvcm0tbm90aWZpY2F0aW9uLnR5cGVcIjtcblxuLyoqXG4gKiBJbXBsZW1lbnRhw6fDo28gZGUgY2xhc3NlIHBhcmEgaW50ZXJjZXB0YXIgZSB0cmF0YXIgcmVxdWlzacOnw7VlcyBodHRwL2h0dHBzXG4gKiBAY2xhc3NcbiAqL1xuQEluamVjdGFibGUoe1xuICAgIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5leHBvcnQgY2xhc3MgRm9ybU5vdGlmaWNhdGlvbkludGVyY2VwdG9yIGltcGxlbWVudHMgSHR0cEludGVyY2VwdG9yIHtcblxuICAgIC8qKlxuICAgICAqIE3DqXRvZG8gY29uc3RydXRvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QWJzdHJhY3RBdXRoZW50aWNhdGlvbn0gYXV0aFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZm9ybU5vdGlmaWNhdGlvblNlcnZpY2U6IEZvcm1Ob3RpZmljYXRpb25TZXJ2aWNlKSB7fVxuXG4gICAgLyoqXG4gICAgICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIGludGVyY2VwdGFyIHJlcXVpc2nDp8O1ZXMgSFRUUC9IVFRQU1xuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge0h0dHBSZXF1ZXN0PGFueT59IHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge0h0dHBIYW5kbGVyfSBuZXh0XG4gICAgICogQHJldHVybnMgT2JzZXJ2YWJsZTxIdHRwRXZlbnQ8YW55Pj5cbiAgICAgKi9cbiAgICBpbnRlcmNlcHQocmVxdWVzdDogSHR0cFJlcXVlc3Q8YW55PiwgbmV4dDogSHR0cEhhbmRsZXIpOiBPYnNlcnZhYmxlPEh0dHBFdmVudDxhbnk+PiB7XG4gICAgICAgIHRoaXMuZm9ybU5vdGlmaWNhdGlvblNlcnZpY2VcbiAgICAgICAgICAgIC5ub3RpZnkobmV3IENsZWFuRm9ybU5vdGlmaWNhdGlvbihyZXF1ZXN0LnVybCkpO1xuICAgICAgICByZXR1cm4gbmV4dC5oYW5kbGUocmVxdWVzdCk7XG4gICAgfVxuXG59XG4iXX0=