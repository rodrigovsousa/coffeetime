import { __decorate } from "tslib";
import { Injectable } from '@angular/core';
import { Authentication } from './authentication';
import * as i0 from "@angular/core";
import * as i1 from "./authentication";
/**
 * Guard que verifica se usuário está autenticado antes do usuário acessar uma rota.
 * Se for verificar que o usuário não está autenticado, é feito um redirecionamento para o login.
 * @class
 */
let AuthGuard = class AuthGuard {
    /**
     * Método construtor responsável pela injeção do serviço de autenticação
     * @constructor
     * @param {Authentication} auth
     */
    constructor(authenticationService) {
        this.authenticationService = authenticationService;
    }
    /**
     * Método responsável por identificar se o usuário está autenticado
     * @public
     * @param {ActivatedRouteSnapshot} route
     * @param {RouterStateSnapshot} state
     * @returns boolean
     */
    canActivate(route, state) {
        if (this.authenticationService.isAuthenticated()) {
            return true;
        }
        this.authenticationService.redirect();
        return false;
    }
    /**
     * Método responsável por atuar somente em rotas filhas de modo independente
     * @public
     * @param {ActivatedRouteSnapshot} route
     * @param {RouterStateSnapshot} state
     * @returns boolean
     */
    canActivateChild(route, state) {
        return this.canActivate(route, state);
    }
};
AuthGuard.ctorParameters = () => [
    { type: Authentication }
];
AuthGuard.ɵprov = i0.ɵɵdefineInjectable({ factory: function AuthGuard_Factory() { return new AuthGuard(i0.ɵɵinject(i1.Authentication)); }, token: AuthGuard, providedIn: "root" });
AuthGuard = __decorate([
    Injectable({
        providedIn: 'root',
    })
], AuthGuard);
export { AuthGuard };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aC5ndWFyZC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BudXZlbS9hbmd1bGFyLWJhc2UvIiwic291cmNlcyI6WyJsaWIvc2VjdXJpdHkvYXV0aGVudGljYXRpb24vYXV0aC5ndWFyZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUUzQyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sa0JBQWtCLENBQUM7OztBQUdsRDs7OztHQUlHO0FBSUgsSUFBYSxTQUFTLEdBQXRCLE1BQWEsU0FBUztJQUVsQjs7OztPQUlHO0lBQ0gsWUFBb0IscUJBQTJDO1FBQTNDLDBCQUFxQixHQUFyQixxQkFBcUIsQ0FBc0I7SUFBRyxDQUFDO0lBRW5FOzs7Ozs7T0FNRztJQUNILFdBQVcsQ0FBQyxLQUE2QixFQUFFLEtBQTBCO1FBQ2pFLElBQUksSUFBSSxDQUFDLHFCQUFxQixDQUFDLGVBQWUsRUFBRSxFQUFFO1lBQzlDLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7UUFDRCxJQUFJLENBQUMscUJBQXFCLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDdEMsT0FBTyxLQUFLLENBQUM7SUFDakIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILGdCQUFnQixDQUFDLEtBQTZCLEVBQUUsS0FBMEI7UUFDdEUsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztJQUMxQyxDQUFDO0NBRUosQ0FBQTs7WUE1QjhDLGNBQWM7OztBQVBoRCxTQUFTO0lBSHJCLFVBQVUsQ0FBQztRQUNSLFVBQVUsRUFBRSxNQUFNO0tBQ3JCLENBQUM7R0FDVyxTQUFTLENBbUNyQjtTQW5DWSxTQUFTIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2FuQWN0aXZhdGUsIENhbkFjdGl2YXRlQ2hpbGQsIEFjdGl2YXRlZFJvdXRlU25hcHNob3QsIFJvdXRlclN0YXRlU25hcHNob3QgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgQXV0aGVudGljYXRpb24gfSBmcm9tICcuL2F1dGhlbnRpY2F0aW9uJztcbmltcG9ydCB7IFVzZXIgfSBmcm9tICcuL3VzZXInO1xuXG4vKipcbiAqIEd1YXJkIHF1ZSB2ZXJpZmljYSBzZSB1c3XDoXJpbyBlc3TDoSBhdXRlbnRpY2FkbyBhbnRlcyBkbyB1c3XDoXJpbyBhY2Vzc2FyIHVtYSByb3RhLiBcbiAqIFNlIGZvciB2ZXJpZmljYXIgcXVlIG8gdXN1w6FyaW8gbsOjbyBlc3TDoSBhdXRlbnRpY2Fkbywgw6kgZmVpdG8gdW0gcmVkaXJlY2lvbmFtZW50byBwYXJhIG8gbG9naW4uXG4gKiBAY2xhc3NcbiAqL1xuQEluamVjdGFibGUoe1xuICAgIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5leHBvcnQgY2xhc3MgQXV0aEd1YXJkIGltcGxlbWVudHMgQ2FuQWN0aXZhdGUsIENhbkFjdGl2YXRlQ2hpbGQge1xuXG4gICAgLyoqXG4gICAgICogTcOpdG9kbyBjb25zdHJ1dG9yIHJlc3BvbnPDoXZlbCBwZWxhIGluamXDp8OjbyBkbyBzZXJ2acOnbyBkZSBhdXRlbnRpY2HDp8Ojb1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXV0aGVudGljYXRpb259IGF1dGhcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGF1dGhlbnRpY2F0aW9uU2VydmljZTogQXV0aGVudGljYXRpb248VXNlcj4pIHt9XG5cbiAgICAvKipcbiAgICAgKiBNw6l0b2RvIHJlc3BvbnPDoXZlbCBwb3IgaWRlbnRpZmljYXIgc2UgbyB1c3XDoXJpbyBlc3TDoSBhdXRlbnRpY2Fkb1xuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge0FjdGl2YXRlZFJvdXRlU25hcHNob3R9IHJvdXRlXG4gICAgICogQHBhcmFtIHtSb3V0ZXJTdGF0ZVNuYXBzaG90fSBzdGF0ZVxuICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgKi9cbiAgICBjYW5BY3RpdmF0ZShyb3V0ZTogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCwgc3RhdGU6IFJvdXRlclN0YXRlU25hcHNob3QpIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0aGVudGljYXRpb25TZXJ2aWNlLmlzQXV0aGVudGljYXRlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF1dGhlbnRpY2F0aW9uU2VydmljZS5yZWRpcmVjdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIGF0dWFyIHNvbWVudGUgZW0gcm90YXMgZmlsaGFzIGRlIG1vZG8gaW5kZXBlbmRlbnRlXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7QWN0aXZhdGVkUm91dGVTbmFwc2hvdH0gcm91dGVcbiAgICAgKiBAcGFyYW0ge1JvdXRlclN0YXRlU25hcHNob3R9IHN0YXRlXG4gICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAqL1xuICAgIGNhbkFjdGl2YXRlQ2hpbGQocm91dGU6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QsIHN0YXRlOiBSb3V0ZXJTdGF0ZVNuYXBzaG90KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbkFjdGl2YXRlKHJvdXRlLCBzdGF0ZSk7XG4gICAgfVxuXG59XG4iXX0=