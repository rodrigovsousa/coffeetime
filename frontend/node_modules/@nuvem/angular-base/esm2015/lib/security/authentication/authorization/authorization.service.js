import { __decorate } from "tslib";
import { Injectable } from '@angular/core';
import { Authorization } from './authorization';
import { Authentication } from '../authentication';
import * as i0 from "@angular/core";
import * as i1 from "../authentication";
/**
 * Serviço de autorização
 * @class
 */
let AuthorizationService = class AuthorizationService extends Authorization {
    /**
     * Método construtor para a injeção do serviço de configuração AuthConfig
     * @constructor
     * @param {AuthConfig} config
     */
    constructor(authenticationService) {
        super();
        this.authenticationService = authenticationService;
    }
    /**
     * Método responsável por identificar as regras de acesso
     * @public
     * @param {any} role
     * @returns boolean
     */
    hasRole(role) {
        if (role) {
            const user = this.authenticationService.getUser();
            if (role instanceof Array) {
                return user.roles.some((userRole) => role.some((checkRole) => userRole === checkRole));
            }
            return user.roles.some((userRole) => userRole === role);
        }
        return true;
    }
};
AuthorizationService.ctorParameters = () => [
    { type: Authentication }
];
AuthorizationService.ɵprov = i0.ɵɵdefineInjectable({ factory: function AuthorizationService_Factory() { return new AuthorizationService(i0.ɵɵinject(i1.Authentication)); }, token: AuthorizationService, providedIn: "root" });
AuthorizationService = __decorate([
    Injectable({
        providedIn: 'root',
    })
], AuthorizationService);
export { AuthorizationService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aG9yaXphdGlvbi5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG51dmVtL2FuZ3VsYXItYmFzZS8iLCJzb3VyY2VzIjpbImxpYi9zZWN1cml0eS9hdXRoZW50aWNhdGlvbi9hdXRob3JpemF0aW9uL2F1dGhvcml6YXRpb24uc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0EsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDaEQsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLG1CQUFtQixDQUFDOzs7QUFHbkQ7OztHQUdHO0FBSUgsSUFBYSxvQkFBb0IsR0FBakMsTUFBYSxvQkFBcUIsU0FBUSxhQUFhO0lBRW5EOzs7O09BSUc7SUFDSCxZQUFvQixxQkFBMkM7UUFDM0QsS0FBSyxFQUFFLENBQUM7UUFEUSwwQkFBcUIsR0FBckIscUJBQXFCLENBQXNCO0lBRS9ELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILE9BQU8sQ0FBQyxJQUFTO1FBQ2IsSUFBSSxJQUFJLEVBQUU7WUFDTixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMscUJBQXFCLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDbEQsSUFBSSxJQUFJLFlBQVksS0FBSyxFQUFFO2dCQUN2QixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBZ0IsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQWlCLEVBQUUsRUFBRSxDQUFDLFFBQVEsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDO2FBQzFHO1lBQ0QsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQWdCLEVBQUUsRUFBRSxDQUFDLFFBQVEsS0FBSyxJQUFJLENBQUMsQ0FBQztTQUNuRTtRQUNELE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7Q0FFSixDQUFBOztZQXJCOEMsY0FBYzs7O0FBUGhELG9CQUFvQjtJQUhoQyxVQUFVLENBQUM7UUFDUixVQUFVLEVBQUUsTUFBTTtLQUNyQixDQUFDO0dBQ1csb0JBQW9CLENBNEJoQztTQTVCWSxvQkFBb0IiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICcuL2F1dGhvcml6YXRpb24nO1xuaW1wb3J0IHsgQXV0aGVudGljYXRpb24gfSBmcm9tICcuLi9hdXRoZW50aWNhdGlvbic7XG5pbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi4vdXNlcic7XG5cbi8qKlxuICogU2VydmnDp28gZGUgYXV0b3JpemHDp8OjbyBcbiAqIEBjbGFzc1xuICovXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBBdXRob3JpemF0aW9uU2VydmljZSBleHRlbmRzIEF1dGhvcml6YXRpb24ge1xuXG4gICAgLyoqXG4gICAgICogTcOpdG9kbyBjb25zdHJ1dG9yIHBhcmEgYSBpbmplw6fDo28gZG8gc2VydmnDp28gZGUgY29uZmlndXJhw6fDo28gQXV0aENvbmZpZ1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXV0aENvbmZpZ30gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBhdXRoZW50aWNhdGlvblNlcnZpY2U6IEF1dGhlbnRpY2F0aW9uPFVzZXI+KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIGlkZW50aWZpY2FyIGFzIHJlZ3JhcyBkZSBhY2Vzc29cbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHthbnl9IHJvbGVcbiAgICAgKiBAcmV0dXJucyBib29sZWFuXG4gICAgICovXG4gICAgaGFzUm9sZShyb2xlOiBhbnkpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHJvbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXIgPSB0aGlzLmF1dGhlbnRpY2F0aW9uU2VydmljZS5nZXRVc2VyKCk7XG4gICAgICAgICAgICBpZiAocm9sZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZXIucm9sZXMuc29tZSgodXNlclJvbGU6IHN0cmluZykgPT4gcm9sZS5zb21lKChjaGVja1JvbGU6IHN0cmluZykgPT4gdXNlclJvbGUgPT09IGNoZWNrUm9sZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVzZXIucm9sZXMuc29tZSgodXNlclJvbGU6IHN0cmluZykgPT4gdXNlclJvbGUgPT09IHJvbGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxufVxuIl19