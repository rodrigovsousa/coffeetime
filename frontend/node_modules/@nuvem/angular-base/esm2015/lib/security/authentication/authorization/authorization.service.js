import { __decorate } from "tslib";
import { Injectable } from '@angular/core';
import { Authorization } from './authorization';
import { Authentication } from '../authentication';
import * as i0 from "@angular/core";
import * as i1 from "../authentication";
/**
 * Serviço de autorização
 * @class
 */
import * as ɵngcc0 from '@angular/core';
let AuthorizationService = class AuthorizationService extends Authorization {
    /**
     * Método construtor para a injeção do serviço de configuração AuthConfig
     * @constructor
     * @param {AuthConfig} config
     */
    constructor(authenticationService) {
        super();
        this.authenticationService = authenticationService;
    }
    /**
     * Método responsável por identificar as regras de acesso
     * @public
     * @param {any} role
     * @returns boolean
     */
    hasRole(role) {
        if (role) {
            const user = this.authenticationService.getUser();
            if (role instanceof Array) {
                return user.roles.some((userRole) => role.some((checkRole) => userRole === checkRole));
            }
            return user.roles.some((userRole) => userRole === role);
        }
        return true;
    }
};
AuthorizationService.ɵfac = function AuthorizationService_Factory(t) { return new (t || AuthorizationService)(ɵngcc0.ɵɵinject(Authentication)); };
AuthorizationService.ctorParameters = () => [
    { type: Authentication }
];
AuthorizationService.ɵprov = i0.ɵɵdefineInjectable({ factory: function AuthorizationService_Factory() { return new AuthorizationService(i0.ɵɵinject(i1.Authentication)); }, token: AuthorizationService, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AuthorizationService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: Authentication }]; }, null); })();
export { AuthorizationService };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aG9yaXphdGlvbi5zZXJ2aWNlLmpzIiwic291cmNlcyI6WyJuZzovQG51dmVtL2FuZ3VsYXItYmFzZS9saWIvc2VjdXJpdHkvYXV0aGVudGljYXRpb24vYXV0aG9yaXphdGlvbi9hdXRob3JpemF0aW9uLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ2hELE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNuRDtBQUdBO0FBREE7QUFDQTtBQUEwQjtBQUNqQixHQUNOOztBQUlILElBQWEsb0JBQW9CLEdBQWpDLE1BQWEsb0JBQXFCLFNBQVEsYUFBYTtBQUN2RCxJQUNJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLElBQUksWUFBb0IscUJBQTJDO0FBQ25FLFFBQVEsS0FBSyxFQUFFLENBQUM7QUFDaEIsUUFGd0IsMEJBQXFCLEdBQXJCLHFCQUFxQixDQUFzQjtBQUFDLElBRWhFLENBQUM7QUFDTCxJQUNJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsSUFBSSxPQUFPLENBQUMsSUFBUztBQUFJLFFBQ2pCLElBQUksSUFBSSxFQUFFO0FBQ2xCLFlBQVksTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQzlELFlBQVksSUFBSSxJQUFJLFlBQVksS0FBSyxFQUFFO0FBQ3ZDLGdCQUFnQixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBZ0IsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQWlCLEVBQUUsRUFBRSxDQUFDLFFBQVEsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDO0FBQ3ZILGFBQWE7QUFDYixZQUFZLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFnQixFQUFFLEVBQUUsQ0FBQyxRQUFRLEtBQUssSUFBSSxDQUFDLENBQUM7QUFDNUUsU0FBUztBQUNULFFBQVEsT0FBTyxJQUFJLENBQUM7QUFDcEIsSUFBSSxDQUFDO0FBQ0wsQ0FDQztrSkFBQTtBQUNEO0FBQThDLFlBdEJDLGNBQWM7QUFBRztBQUFHO0FBUHRELG9CQUFvQixvQkFIaEMsVUFBVSxDQUFDLFVBQ1IsVUFBVSxFQUFFO0FBQU0sT0FDckIsQ0FBQyxJQUNXO01BQW9CLENBNEJoQzs7O3dFQUNEO0FBQUMsU0E3Qlksb0JBQW9CO0FBQUkiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICcuL2F1dGhvcml6YXRpb24nO1xuaW1wb3J0IHsgQXV0aGVudGljYXRpb24gfSBmcm9tICcuLi9hdXRoZW50aWNhdGlvbic7XG5pbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi4vdXNlcic7XG5cbi8qKlxuICogU2VydmnDp28gZGUgYXV0b3JpemHDp8OjbyBcbiAqIEBjbGFzc1xuICovXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBBdXRob3JpemF0aW9uU2VydmljZSBleHRlbmRzIEF1dGhvcml6YXRpb24ge1xuXG4gICAgLyoqXG4gICAgICogTcOpdG9kbyBjb25zdHJ1dG9yIHBhcmEgYSBpbmplw6fDo28gZG8gc2VydmnDp28gZGUgY29uZmlndXJhw6fDo28gQXV0aENvbmZpZ1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXV0aENvbmZpZ30gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBhdXRoZW50aWNhdGlvblNlcnZpY2U6IEF1dGhlbnRpY2F0aW9uPFVzZXI+KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIGlkZW50aWZpY2FyIGFzIHJlZ3JhcyBkZSBhY2Vzc29cbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHthbnl9IHJvbGVcbiAgICAgKiBAcmV0dXJucyBib29sZWFuXG4gICAgICovXG4gICAgaGFzUm9sZShyb2xlOiBhbnkpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHJvbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXIgPSB0aGlzLmF1dGhlbnRpY2F0aW9uU2VydmljZS5nZXRVc2VyKCk7XG4gICAgICAgICAgICBpZiAocm9sZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZXIucm9sZXMuc29tZSgodXNlclJvbGU6IHN0cmluZykgPT4gcm9sZS5zb21lKChjaGVja1JvbGU6IHN0cmluZykgPT4gdXNlclJvbGUgPT09IGNoZWNrUm9sZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVzZXIucm9sZXMuc29tZSgodXNlclJvbGU6IHN0cmluZykgPT4gdXNlclJvbGUgPT09IHJvbGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxufVxuIl19