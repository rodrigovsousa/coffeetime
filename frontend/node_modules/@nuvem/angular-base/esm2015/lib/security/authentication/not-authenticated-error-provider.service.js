import { __decorate } from "tslib";
import { Injectable } from '@angular/core';
import { HttpErrorResponse } from '@angular/common/http';
import { Authentication } from './authentication';
import * as i0 from "@angular/core";
import * as i1 from "./authentication";
/**
 * Provedor de error para criação de erros de notificação.
 * @class
 */
import * as ɵngcc0 from '@angular/core';
let NotAuthenticatedErrorProvider = class NotAuthenticatedErrorProvider {
    constructor(authenticationService) {
        this.authenticationService = authenticationService;
    }
    /**
     * Método para identificar se o usuário está logado
     * @public
     * @param {HttpErrorResponse} error
     * @returns void
     */
    shouldHandle(error) {
        return error instanceof HttpErrorResponse && error.status == 401;
    }
    /**
     * Método para redirecionar caso o usuário não esteja
     * @public
     * @param {HttpErrorResponse} error
     * @returns void
     */
    handle(error) {
        this.authenticationService.redirect();
    }
};
NotAuthenticatedErrorProvider.ɵfac = function NotAuthenticatedErrorProvider_Factory(t) { return new (t || NotAuthenticatedErrorProvider)(ɵngcc0.ɵɵinject(Authentication)); };
NotAuthenticatedErrorProvider.ctorParameters = () => [
    { type: Authentication }
];
NotAuthenticatedErrorProvider.ɵprov = i0.ɵɵdefineInjectable({ factory: function NotAuthenticatedErrorProvider_Factory() { return new NotAuthenticatedErrorProvider(i0.ɵɵinject(i1.Authentication)); }, token: NotAuthenticatedErrorProvider, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NotAuthenticatedErrorProvider, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: Authentication }]; }, null); })();
export { NotAuthenticatedErrorProvider };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm90LWF1dGhlbnRpY2F0ZWQtZXJyb3ItcHJvdmlkZXIuc2VydmljZS5qcyIsInNvdXJjZXMiOlsibmc6L0BudXZlbS9hbmd1bGFyLWJhc2UvbGliL3NlY3VyaXR5L2F1dGhlbnRpY2F0aW9uL25vdC1hdXRoZW50aWNhdGVkLWVycm9yLXByb3ZpZGVyLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFFekQsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ2xEO0FBR0M7QUFERDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUlILElBQWEsNkJBQTZCLEdBQTFDLE1BQWEsNkJBQTZCO0FBQUcsSUFFekMsWUFBb0IscUJBQTJDO0FBQUksUUFBL0MsMEJBQXFCLEdBQXJCLHFCQUFxQixDQUFzQjtBQUFDLElBQUcsQ0FBQztBQUN4RSxJQUNJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsSUFBSSxZQUFZLENBQUMsS0FBZ0M7QUFBSSxRQUM3QyxPQUFPLEtBQUssWUFBWSxpQkFBaUIsSUFBSSxLQUFLLENBQUMsTUFBTSxJQUFJLEdBQUcsQ0FBQztBQUN6RSxJQUFJLENBQUM7QUFDTCxJQUNJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsSUFBSSxNQUFNLENBQUMsS0FBd0I7QUFBSSxRQUMvQixJQUFJLENBQUMscUJBQXFCLENBQUMsUUFBUSxFQUFFLENBQUM7QUFDOUMsSUFBSSxDQUFDO0FBQ0wsQ0FDQzs2S0FBQTtBQUNEO0FBQXVELFlBdkJSLGNBQWM7QUFBRztBQUFHO0FBRnRELDZCQUE2QixvQkFIekMsVUFBVSxDQUFDLFVBQ1IsVUFBVSxFQUFFO0FBQU0sT0FDckIsQ0FBQyxJQUNXO2VBQTZCLENBd0J6Qzs7O3dFQUNEO0FBQUMsU0F6QlksNkJBQTZCO0FBQUkiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEh0dHBFcnJvclJlc3BvbnNlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0IHsgRXJyb3JQcm92aWRlciB9IGZyb20gJy4uLy4uL2Vycm9yL3Byb3ZpZGVycy9lcnJvci5wcm92aWRlcic7XG5pbXBvcnQgeyBBdXRoZW50aWNhdGlvbiB9IGZyb20gJy4vYXV0aGVudGljYXRpb24nO1xuaW1wb3J0IHsgVXNlciB9IGZyb20gJy4vdXNlcic7XG5cbi8qKlxuICogUHJvdmVkb3IgZGUgZXJyb3IgcGFyYSBjcmlhw6fDo28gZGUgZXJyb3MgZGUgbm90aWZpY2HDp8Ojby5cbiAqIEBjbGFzc1xuICovXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBOb3RBdXRoZW50aWNhdGVkRXJyb3JQcm92aWRlciBpbXBsZW1lbnRzIEVycm9yUHJvdmlkZXIge1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBhdXRoZW50aWNhdGlvblNlcnZpY2U6IEF1dGhlbnRpY2F0aW9uPFVzZXI+KSB7IH1cblxuICAgIC8qKlxuICAgICAqIE3DqXRvZG8gcGFyYSBpZGVudGlmaWNhciBzZSBvIHVzdcOhcmlvIGVzdMOhIGxvZ2Fkb1xuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge0h0dHBFcnJvclJlc3BvbnNlfSBlcnJvclxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBzaG91bGRIYW5kbGUoZXJyb3I6IEVycm9yIHwgSHR0cEVycm9yUmVzcG9uc2UpOiBCb29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgSHR0cEVycm9yUmVzcG9uc2UgJiYgZXJyb3Iuc3RhdHVzID09IDQwMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNw6l0b2RvIHBhcmEgcmVkaXJlY2lvbmFyIGNhc28gbyB1c3XDoXJpbyBuw6NvIGVzdGVqYVxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge0h0dHBFcnJvclJlc3BvbnNlfSBlcnJvclxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBoYW5kbGUoZXJyb3I6IEh0dHBFcnJvclJlc3BvbnNlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYXV0aGVudGljYXRpb25TZXJ2aWNlLnJlZGlyZWN0KCk7XG4gICAgfVxuXG59XG4iXX0=