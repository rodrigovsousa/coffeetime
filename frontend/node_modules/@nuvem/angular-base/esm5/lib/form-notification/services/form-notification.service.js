import { __decorate } from "tslib";
import { Injectable } from '@angular/core';
import { Subject } from 'rxjs';
import { FormNotificationType } from '../types/form-notification.type';
import { filter } from 'rxjs/operators';
import { FieldFormNotification } from '../types/field-form-notification.type';
import * as i0 from "@angular/core";
/**
 * Serviço ṕara tratar notificações em formulários
 * @class
 */
import * as ɵngcc0 from '@angular/core';
var FormNotificationService = /** @class */ (function () {
    function FormNotificationService() {
        /**
         * @type {Subject<FormNotification>()}
         */
        this.formNotifications = new Subject();
    }
    /**
     * Método para criação de inscrição de campos presentes nos formulários
     * @param {string} field
     * @returns Observable<ResponseHandle>
     */
    FormNotificationService.prototype.notifications = function (form, field) {
        return this.formNotifications.pipe(filter(function (violation) {
            return (!form || violation.form === form) && (violation.type === FormNotificationType.CLEAN || (violation instanceof FieldFormNotification &&
                violation.field === field));
        }));
    };
    FormNotificationService.prototype.notify = function (notification) {
        this.formNotifications.next(notification);
    };
    FormNotificationService.ɵprov = i0.ɵɵdefineInjectable({ factory: function FormNotificationService_Factory() { return new FormNotificationService(); }, token: FormNotificationService, providedIn: "root" });
FormNotificationService.ɵfac = function FormNotificationService_Factory(t) { return new (t || FormNotificationService)(); };
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FormNotificationService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();
    return FormNotificationService;
}());
export { FormNotificationService };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9ybS1ub3RpZmljYXRpb24uc2VydmljZS5qcyIsInNvdXJjZXMiOlsibmc6L0BudXZlbS9hbmd1bGFyLWJhc2UvbGliL2Zvcm0tbm90aWZpY2F0aW9uL3NlcnZpY2VzL2Zvcm0tbm90aWZpY2F0aW9uLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFjLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMzQyxPQUFPLEVBQW9CLG9CQUFvQixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDekYsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3hDLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHVDQUF1QyxDQUFDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFJSDtBQUdXLElBSFg7QUFBcUMsUUFFakM7QUFDSjtBQUNJLFdBQUc7QUFDUCxRQUFJLHNCQUFpQixHQUNiLElBQUksT0FBTyxFQUFvQixDQUFDO0FBQ3hDLEtBb0JDO0FBQ0QsSUFwQkk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsSUFBSSwrQ0FBYSxHQUFiLFVBQWMsSUFBWSxFQUFFLEtBQWE7QUFBSSxRQUN6QyxPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUNyQyxVQUFDLFNBQTJCO0FBQUksWUFDNUIsT0FBTyxDQUFDLENBQUMsSUFBSSxJQUFJLFNBQVMsQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxLQUFLLG9CQUFvQixDQUFDLEtBQUssSUFBSSxDQUMzRixTQUFTLFlBQVkscUJBQXFCO0FBQzlELGdCQUFvQixTQUFTLENBQUMsS0FBSyxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUE7QUFDL0MsUUFBWSxDQUFDLENBQ0osQ0FBQyxDQUFDO0FBQ1gsSUFBSSxDQUFDO0FBRUwsSUFBSSx3Q0FBTSxHQUFOLFVBQU8sWUFBOEI7QUFDekMsUUFBUSxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ2xELElBQUksQ0FBQztBQUVMO0lBM0JhLHVCQUF1Qix3QkFIbkMsVUFBVSxDQUFDLGNBQ1IsVUFBVSxFQUFFLE1BQU0sV0FDckIsQ0FBQyxRQUNXO1lBQXVCLENBMkJuQzs7Ozs7Z0RBQ0Q7QUFBQyxrQ0F6Q0Q7QUFBRSxDQXdDRCxBQTNCRCxJQTJCQztBQUNELFNBNUJhLHVCQUF1QjtBQUVwQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IEZvcm1Ob3RpZmljYXRpb24sIEZvcm1Ob3RpZmljYXRpb25UeXBlIH0gZnJvbSAnLi4vdHlwZXMvZm9ybS1ub3RpZmljYXRpb24udHlwZSc7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBGaWVsZEZvcm1Ob3RpZmljYXRpb24gfSBmcm9tICcuLi90eXBlcy9maWVsZC1mb3JtLW5vdGlmaWNhdGlvbi50eXBlJztcblxuLyoqXG4gKiBTZXJ2acOnbyDhuZVhcmEgdHJhdGFyIG5vdGlmaWNhw6fDtWVzIGVtIGZvcm11bMOhcmlvc1xuICogQGNsYXNzXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIEZvcm1Ob3RpZmljYXRpb25TZXJ2aWNlIHtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtTdWJqZWN0PEZvcm1Ob3RpZmljYXRpb24+KCl9XG4gICAgICovXG4gICAgZm9ybU5vdGlmaWNhdGlvbnM6IFN1YmplY3Q8Rm9ybU5vdGlmaWNhdGlvbj4gPVxuICAgICAgICBuZXcgU3ViamVjdDxGb3JtTm90aWZpY2F0aW9uPigpO1xuXG4gICAgLyoqXG4gICAgICogTcOpdG9kbyBwYXJhIGNyaWHDp8OjbyBkZSBpbnNjcmnDp8OjbyBkZSBjYW1wb3MgcHJlc2VudGVzIG5vcyBmb3JtdWzDoXJpb3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGRcbiAgICAgKiBAcmV0dXJucyBPYnNlcnZhYmxlPFJlc3BvbnNlSGFuZGxlPlxuICAgICAqL1xuICAgIG5vdGlmaWNhdGlvbnMoZm9ybTogU3RyaW5nLCBmaWVsZDogU3RyaW5nKTogT2JzZXJ2YWJsZTxGb3JtTm90aWZpY2F0aW9uPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1Ob3RpZmljYXRpb25zLnBpcGUoZmlsdGVyKFxuICAgICAgICAgICAgKHZpb2xhdGlvbjogRm9ybU5vdGlmaWNhdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoIWZvcm0gfHwgdmlvbGF0aW9uLmZvcm0gPT09IGZvcm0pICYmICh2aW9sYXRpb24udHlwZSA9PT0gRm9ybU5vdGlmaWNhdGlvblR5cGUuQ0xFQU4gfHwgKFxuICAgICAgICAgICAgICAgICAgICB2aW9sYXRpb24gaW5zdGFuY2VvZiBGaWVsZEZvcm1Ob3RpZmljYXRpb24gJiZcbiAgICAgICAgICAgICAgICAgICAgdmlvbGF0aW9uLmZpZWxkID09PSBmaWVsZCkpXG4gICAgICAgICAgICB9XG4gICAgICAgICkpO1xuICAgIH1cblxuICAgIG5vdGlmeShub3RpZmljYXRpb246IEZvcm1Ob3RpZmljYXRpb24pIHtcbiAgICAgICAgdGhpcy5mb3JtTm90aWZpY2F0aW9ucy5uZXh0KG5vdGlmaWNhdGlvbik7XG4gICAgfVxuXG59XG4iXX0=