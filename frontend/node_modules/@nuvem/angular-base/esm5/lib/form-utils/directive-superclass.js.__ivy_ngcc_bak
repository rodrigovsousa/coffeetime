import { __extends } from "tslib";
import { ChangeDetectorRef, } from "@angular/core";
import { Subject } from "rxjs";
import { filter, map, startWith } from "rxjs/operators";
import { InjectableSuperclass } from "./injectable-superclass";
/**
 * Extend this when creating a directive (including a component, which is a kind of directive) to gain access to the helpers demonstrated below. **Warning:** You _must_ include a constructor in your subclass.
 *
 * ```ts
 * @Component({
 *   selector: "s-color-text",
 *   template: `
 *     <span [style.background]="color">{{ color }}</span>
 *   `,
 *   // note that `bindToInstance()` works even with OnPush change detection
 *   changeDetection: ChangeDetectionStrategy.OnPush,
 * })
 *  class ColorTextComponent extends DirectiveSuperclass {
 *   @Input() prefix?: string;
 *   @Input() prefix2?: string;
 *   color!: string;
 *
 *   // Even if you don't need extra arguments injector, you must still include a constructor. It is required for angular to provide `Injector`.
 *   constructor(
 *     @Inject("color$") color$: Observable<string>,
 *     injector: Injector,
 *   ) {
 *     super(injector);
 *
 *     // combine everything to calculate `color` and keep it up to date
 *     this.bindToInstance(
 *       "color",
 *       combineLatest(
 *         this.getInput$("prefix"),
 *         this.getInput$("prefix2"),
 *         color$,
 *       ).pipe(map((parts) => parts.filter((p) => p).join(""))),
 *     );
 *   }
 * }
 * ```
 */
var DirectiveSuperclass = /** @class */ (function (_super) {
    __extends(DirectiveSuperclass, _super);
    function DirectiveSuperclass(injector) {
        var _this = _super.call(this) || this;
        /**
         *  Emits the set of `@Input()` property names that change during each call to `ngOnChanges()`.
         */
        _this.inputChanges$ = new Subject();
        _this.changeDetectorRef = injector.get(ChangeDetectorRef);
        return _this;
    }
    DirectiveSuperclass.prototype.ngOnChanges = function (changes) {
        this.inputChanges$.next(new Set(Object.getOwnPropertyNames(changes)));
    };
    /**
     * @return an observable of the values for one of this directive's `@Input()` properties
     */
    DirectiveSuperclass.prototype.getInput$ = function (key) {
        var _this = this;
        return this.inputChanges$.pipe(filter(function (keys) { return keys.has(key); }), startWith(undefined), map(function () { return _this[key]; }));
    };
    /**
     * Binds an observable to one of this directive's instance variables. When the observable emits the instance variable will be updated, and change detection will be triggered to propagate any changes. Use this an an alternative to repeating `| async` multiple times in your template.
     */
    DirectiveSuperclass.prototype.bindToInstance = function (key, value$) {
        var _this = this;
        this.subscribeTo(value$, function (value) {
            _this[key] = value;
            _this.changeDetectorRef.markForCheck();
        });
    };
    return DirectiveSuperclass;
}(InjectableSuperclass));
export { DirectiveSuperclass };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlyZWN0aXZlLXN1cGVyY2xhc3MuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AbnV2ZW0vYW5ndWxhci1iYXNlLyIsInNvdXJjZXMiOlsibGliL2Zvcm0tdXRpbHMvZGlyZWN0aXZlLXN1cGVyY2xhc3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFDSCxpQkFBaUIsR0FHcEIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFjLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMzQyxPQUFPLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4RCxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUUvRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBb0NHO0FBQ0g7SUFBa0QsdUNBQW9CO0lBU2xFLDZCQUFZLFFBQWtCO1FBQTlCLFlBQ0ksaUJBQU8sU0FFVjtRQVZEOztXQUVHO1FBQ0gsbUJBQWEsR0FBRyxJQUFJLE9BQU8sRUFBTyxDQUFDO1FBTS9CLEtBQUksQ0FBQyxpQkFBaUIsR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLGlCQUFpQixDQUFDLENBQUM7O0lBQzdELENBQUM7SUFFRCx5Q0FBVyxHQUFYLFVBQVksT0FBc0I7UUFDOUIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQ25CLElBQUksR0FBRyxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQXNCLENBQUMsQ0FDcEUsQ0FBQztJQUNOLENBQUM7SUFFRDs7T0FFRztJQUNILHVDQUFTLEdBQVQsVUFBZ0MsR0FBTTtRQUF0QyxpQkFNQztRQUxHLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQzFCLE1BQU0sQ0FBQyxVQUFDLElBQUksSUFBSyxPQUFBLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQWIsQ0FBYSxDQUFDLEVBQy9CLFNBQVMsQ0FBQyxTQUFTLENBQUMsRUFDcEIsR0FBRyxDQUFDLGNBQU0sT0FBQSxLQUFJLENBQUMsR0FBRyxDQUFDLEVBQVQsQ0FBUyxDQUFDLENBQ3ZCLENBQUM7SUFDTixDQUFDO0lBRUQ7O09BRUc7SUFDSCw0Q0FBYyxHQUFkLFVBQXFDLEdBQU0sRUFBRSxNQUEyQjtRQUF4RSxpQkFLQztRQUpHLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLFVBQUMsS0FBSztZQUMzQixLQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDO1lBQ2xCLEtBQUksQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUMxQyxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFDTCwwQkFBQztBQUFELENBQUMsQUF4Q0QsQ0FBa0Qsb0JBQW9CLEdBd0NyRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgSW5qZWN0b3IsXG4gICAgU2ltcGxlQ2hhbmdlcyxcbn0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tIFwicnhqc1wiO1xuaW1wb3J0IHsgZmlsdGVyLCBtYXAsIHN0YXJ0V2l0aCB9IGZyb20gXCJyeGpzL29wZXJhdG9yc1wiO1xuaW1wb3J0IHsgSW5qZWN0YWJsZVN1cGVyY2xhc3MgfSBmcm9tIFwiLi9pbmplY3RhYmxlLXN1cGVyY2xhc3NcIjtcblxuLyoqXG4gKiBFeHRlbmQgdGhpcyB3aGVuIGNyZWF0aW5nIGEgZGlyZWN0aXZlIChpbmNsdWRpbmcgYSBjb21wb25lbnQsIHdoaWNoIGlzIGEga2luZCBvZiBkaXJlY3RpdmUpIHRvIGdhaW4gYWNjZXNzIHRvIHRoZSBoZWxwZXJzIGRlbW9uc3RyYXRlZCBiZWxvdy4gKipXYXJuaW5nOioqIFlvdSBfbXVzdF8gaW5jbHVkZSBhIGNvbnN0cnVjdG9yIGluIHlvdXIgc3ViY2xhc3MuXG4gKlxuICogYGBgdHNcbiAqIEBDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogXCJzLWNvbG9yLXRleHRcIixcbiAqICAgdGVtcGxhdGU6IGBcbiAqICAgICA8c3BhbiBbc3R5bGUuYmFja2dyb3VuZF09XCJjb2xvclwiPnt7IGNvbG9yIH19PC9zcGFuPlxuICogICBgLFxuICogICAvLyBub3RlIHRoYXQgYGJpbmRUb0luc3RhbmNlKClgIHdvcmtzIGV2ZW4gd2l0aCBPblB1c2ggY2hhbmdlIGRldGVjdGlvblxuICogICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAqIH0pXG4gKiAgY2xhc3MgQ29sb3JUZXh0Q29tcG9uZW50IGV4dGVuZHMgRGlyZWN0aXZlU3VwZXJjbGFzcyB7XG4gKiAgIEBJbnB1dCgpIHByZWZpeD86IHN0cmluZztcbiAqICAgQElucHV0KCkgcHJlZml4Mj86IHN0cmluZztcbiAqICAgY29sb3IhOiBzdHJpbmc7XG4gKlxuICogICAvLyBFdmVuIGlmIHlvdSBkb24ndCBuZWVkIGV4dHJhIGFyZ3VtZW50cyBpbmplY3RvciwgeW91IG11c3Qgc3RpbGwgaW5jbHVkZSBhIGNvbnN0cnVjdG9yLiBJdCBpcyByZXF1aXJlZCBmb3IgYW5ndWxhciB0byBwcm92aWRlIGBJbmplY3RvcmAuXG4gKiAgIGNvbnN0cnVjdG9yKFxuICogICAgIEBJbmplY3QoXCJjb2xvciRcIikgY29sb3IkOiBPYnNlcnZhYmxlPHN0cmluZz4sXG4gKiAgICAgaW5qZWN0b3I6IEluamVjdG9yLFxuICogICApIHtcbiAqICAgICBzdXBlcihpbmplY3Rvcik7XG4gKlxuICogICAgIC8vIGNvbWJpbmUgZXZlcnl0aGluZyB0byBjYWxjdWxhdGUgYGNvbG9yYCBhbmQga2VlcCBpdCB1cCB0byBkYXRlXG4gKiAgICAgdGhpcy5iaW5kVG9JbnN0YW5jZShcbiAqICAgICAgIFwiY29sb3JcIixcbiAqICAgICAgIGNvbWJpbmVMYXRlc3QoXG4gKiAgICAgICAgIHRoaXMuZ2V0SW5wdXQkKFwicHJlZml4XCIpLFxuICogICAgICAgICB0aGlzLmdldElucHV0JChcInByZWZpeDJcIiksXG4gKiAgICAgICAgIGNvbG9yJCxcbiAqICAgICAgICkucGlwZShtYXAoKHBhcnRzKSA9PiBwYXJ0cy5maWx0ZXIoKHApID0+IHApLmpvaW4oXCJcIikpKSxcbiAqICAgICApO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIERpcmVjdGl2ZVN1cGVyY2xhc3MgZXh0ZW5kcyBJbmplY3RhYmxlU3VwZXJjbGFzcyB7XG5cbiAgICAvKipcbiAgICAgKiAgRW1pdHMgdGhlIHNldCBvZiBgQElucHV0KClgIHByb3BlcnR5IG5hbWVzIHRoYXQgY2hhbmdlIGR1cmluZyBlYWNoIGNhbGwgdG8gYG5nT25DaGFuZ2VzKClgLlxuICAgICAqL1xuICAgIGlucHV0Q2hhbmdlcyQgPSBuZXcgU3ViamVjdDxhbnk+KCk7XG5cbiAgICBwcm90ZWN0ZWQgY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmO1xuXG4gICAgY29uc3RydWN0b3IoaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYgPSBpbmplY3Rvci5nZXQoQ2hhbmdlRGV0ZWN0b3JSZWYpO1xuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy5pbnB1dENoYW5nZXMkLm5leHQoXG4gICAgICAgICAgICBuZXcgU2V0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNoYW5nZXMpIGFzIEFycmF5PGtleW9mIHRoaXM+KSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIGFuIG9ic2VydmFibGUgb2YgdGhlIHZhbHVlcyBmb3Igb25lIG9mIHRoaXMgZGlyZWN0aXZlJ3MgYEBJbnB1dCgpYCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ2V0SW5wdXQkPEsgZXh0ZW5kcyBrZXlvZiB0aGlzPihrZXk6IEspOiBPYnNlcnZhYmxlPHRoaXNbS10+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRDaGFuZ2VzJC5waXBlKFxuICAgICAgICAgICAgZmlsdGVyKChrZXlzKSA9PiBrZXlzLmhhcyhrZXkpKSxcbiAgICAgICAgICAgIHN0YXJ0V2l0aCh1bmRlZmluZWQpLFxuICAgICAgICAgICAgbWFwKCgpID0+IHRoaXNba2V5XSksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmluZHMgYW4gb2JzZXJ2YWJsZSB0byBvbmUgb2YgdGhpcyBkaXJlY3RpdmUncyBpbnN0YW5jZSB2YXJpYWJsZXMuIFdoZW4gdGhlIG9ic2VydmFibGUgZW1pdHMgdGhlIGluc3RhbmNlIHZhcmlhYmxlIHdpbGwgYmUgdXBkYXRlZCwgYW5kIGNoYW5nZSBkZXRlY3Rpb24gd2lsbCBiZSB0cmlnZ2VyZWQgdG8gcHJvcGFnYXRlIGFueSBjaGFuZ2VzLiBVc2UgdGhpcyBhbiBhbiBhbHRlcm5hdGl2ZSB0byByZXBlYXRpbmcgYHwgYXN5bmNgIG11bHRpcGxlIHRpbWVzIGluIHlvdXIgdGVtcGxhdGUuXG4gICAgICovXG4gICAgYmluZFRvSW5zdGFuY2U8SyBleHRlbmRzIGtleW9mIHRoaXM+KGtleTogSywgdmFsdWUkOiBPYnNlcnZhYmxlPHRoaXNbS10+KSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG8odmFsdWUkLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl19