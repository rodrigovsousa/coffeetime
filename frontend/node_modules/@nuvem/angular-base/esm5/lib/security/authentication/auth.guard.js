import { __decorate } from "tslib";
import { Injectable } from '@angular/core';
import { Authentication } from './authentication';
import * as i0 from "@angular/core";
import * as i1 from "./authentication";
/**
 * Guard que verifica se usuário está autenticado antes do usuário acessar uma rota.
 * Se for verificar que o usuário não está autenticado, é feito um redirecionamento para o login.
 * @class
 */
var AuthGuard = /** @class */ (function () {
    /**
     * Método construtor responsável pela injeção do serviço de autenticação
     * @constructor
     * @param {Authentication} auth
     */
    function AuthGuard(authenticationService) {
        this.authenticationService = authenticationService;
    }
    /**
     * Método responsável por identificar se o usuário está autenticado
     * @public
     * @param {ActivatedRouteSnapshot} route
     * @param {RouterStateSnapshot} state
     * @returns boolean
     */
    AuthGuard.prototype.canActivate = function (route, state) {
        if (this.authenticationService.isAuthenticated()) {
            return true;
        }
        this.authenticationService.redirect();
        return false;
    };
    /**
     * Método responsável por atuar somente em rotas filhas de modo independente
     * @public
     * @param {ActivatedRouteSnapshot} route
     * @param {RouterStateSnapshot} state
     * @returns boolean
     */
    AuthGuard.prototype.canActivateChild = function (route, state) {
        return this.canActivate(route, state);
    };
    AuthGuard.ctorParameters = function () { return [
        { type: Authentication }
    ]; };
    AuthGuard.ɵprov = i0.ɵɵdefineInjectable({ factory: function AuthGuard_Factory() { return new AuthGuard(i0.ɵɵinject(i1.Authentication)); }, token: AuthGuard, providedIn: "root" });
    AuthGuard = __decorate([
        Injectable({
            providedIn: 'root',
        })
    ], AuthGuard);
    return AuthGuard;
}());
export { AuthGuard };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aC5ndWFyZC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BudXZlbS9hbmd1bGFyLWJhc2UvIiwic291cmNlcyI6WyJsaWIvc2VjdXJpdHkvYXV0aGVudGljYXRpb24vYXV0aC5ndWFyZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUUzQyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sa0JBQWtCLENBQUM7OztBQUdsRDs7OztHQUlHO0FBSUg7SUFFSTs7OztPQUlHO0lBQ0gsbUJBQW9CLHFCQUEyQztRQUEzQywwQkFBcUIsR0FBckIscUJBQXFCLENBQXNCO0lBQUcsQ0FBQztJQUVuRTs7Ozs7O09BTUc7SUFDSCwrQkFBVyxHQUFYLFVBQVksS0FBNkIsRUFBRSxLQUEwQjtRQUNqRSxJQUFJLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxlQUFlLEVBQUUsRUFBRTtZQUM5QyxPQUFPLElBQUksQ0FBQztTQUNmO1FBQ0QsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3RDLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxvQ0FBZ0IsR0FBaEIsVUFBaUIsS0FBNkIsRUFBRSxLQUEwQjtRQUN0RSxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQzFDLENBQUM7O2dCQTFCMEMsY0FBYzs7O0lBUGhELFNBQVM7UUFIckIsVUFBVSxDQUFDO1lBQ1IsVUFBVSxFQUFFLE1BQU07U0FDckIsQ0FBQztPQUNXLFNBQVMsQ0FtQ3JCO29CQWhERDtDQWdEQyxBQW5DRCxJQW1DQztTQW5DWSxTQUFTIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2FuQWN0aXZhdGUsIENhbkFjdGl2YXRlQ2hpbGQsIEFjdGl2YXRlZFJvdXRlU25hcHNob3QsIFJvdXRlclN0YXRlU25hcHNob3QgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgQXV0aGVudGljYXRpb24gfSBmcm9tICcuL2F1dGhlbnRpY2F0aW9uJztcbmltcG9ydCB7IFVzZXIgfSBmcm9tICcuL3VzZXInO1xuXG4vKipcbiAqIEd1YXJkIHF1ZSB2ZXJpZmljYSBzZSB1c3XDoXJpbyBlc3TDoSBhdXRlbnRpY2FkbyBhbnRlcyBkbyB1c3XDoXJpbyBhY2Vzc2FyIHVtYSByb3RhLiBcbiAqIFNlIGZvciB2ZXJpZmljYXIgcXVlIG8gdXN1w6FyaW8gbsOjbyBlc3TDoSBhdXRlbnRpY2Fkbywgw6kgZmVpdG8gdW0gcmVkaXJlY2lvbmFtZW50byBwYXJhIG8gbG9naW4uXG4gKiBAY2xhc3NcbiAqL1xuQEluamVjdGFibGUoe1xuICAgIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5leHBvcnQgY2xhc3MgQXV0aEd1YXJkIGltcGxlbWVudHMgQ2FuQWN0aXZhdGUsIENhbkFjdGl2YXRlQ2hpbGQge1xuXG4gICAgLyoqXG4gICAgICogTcOpdG9kbyBjb25zdHJ1dG9yIHJlc3BvbnPDoXZlbCBwZWxhIGluamXDp8OjbyBkbyBzZXJ2acOnbyBkZSBhdXRlbnRpY2HDp8Ojb1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXV0aGVudGljYXRpb259IGF1dGhcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGF1dGhlbnRpY2F0aW9uU2VydmljZTogQXV0aGVudGljYXRpb248VXNlcj4pIHt9XG5cbiAgICAvKipcbiAgICAgKiBNw6l0b2RvIHJlc3BvbnPDoXZlbCBwb3IgaWRlbnRpZmljYXIgc2UgbyB1c3XDoXJpbyBlc3TDoSBhdXRlbnRpY2Fkb1xuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge0FjdGl2YXRlZFJvdXRlU25hcHNob3R9IHJvdXRlXG4gICAgICogQHBhcmFtIHtSb3V0ZXJTdGF0ZVNuYXBzaG90fSBzdGF0ZVxuICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgKi9cbiAgICBjYW5BY3RpdmF0ZShyb3V0ZTogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCwgc3RhdGU6IFJvdXRlclN0YXRlU25hcHNob3QpIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0aGVudGljYXRpb25TZXJ2aWNlLmlzQXV0aGVudGljYXRlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF1dGhlbnRpY2F0aW9uU2VydmljZS5yZWRpcmVjdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIGF0dWFyIHNvbWVudGUgZW0gcm90YXMgZmlsaGFzIGRlIG1vZG8gaW5kZXBlbmRlbnRlXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7QWN0aXZhdGVkUm91dGVTbmFwc2hvdH0gcm91dGVcbiAgICAgKiBAcGFyYW0ge1JvdXRlclN0YXRlU25hcHNob3R9IHN0YXRlXG4gICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAqL1xuICAgIGNhbkFjdGl2YXRlQ2hpbGQocm91dGU6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QsIHN0YXRlOiBSb3V0ZXJTdGF0ZVNuYXBzaG90KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbkFjdGl2YXRlKHJvdXRlLCBzdGF0ZSk7XG4gICAgfVxuXG59XG4iXX0=