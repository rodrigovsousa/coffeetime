import { __decorate } from "tslib";
import { HttpResponse } from "@angular/common/http";
import { Injectable } from "@angular/core";
import { tap } from 'rxjs/operators';
import { Token } from "./token";
import * as i0 from "@angular/core";
import * as i1 from "./token";
/**
 * Implementação de classe para interceptar e tratar requisições http/https
 * @class
 */
var JWTAuthInterceptor = /** @class */ (function () {
    /**
     * Metodo construtor responsável por injetar serviço de autenticação
     * @constructor
     * @param {AbstractAuthentication} auth
     */
    function JWTAuthInterceptor(token) {
        this.token = token;
    }
    /**
     * Metodo responsável por interceptar requisições HTTP/HTTPS
     * @public
     * @param {HttpRequest<any>} request
     * @param {HttpHandler} next
     * @returns Observable<HttpEvent<any>>
     */
    JWTAuthInterceptor.prototype.intercept = function (request, next) {
        var _this = this;
        if (this.token.hasToken()) {
            request = this.token.setTokenInHeader(request);
        }
        return next.handle(request)
            .pipe(tap(function (event) {
            if (event instanceof HttpResponse) {
                var token = _this.token.extractTokenFromHeaders(event.headers);
                if (null !== token)
                    _this.token.storeToken(token);
            }
            return event;
        }));
    };
    JWTAuthInterceptor.ctorParameters = function () { return [
        { type: Token }
    ]; };
    JWTAuthInterceptor.ɵprov = i0.ɵɵdefineInjectable({ factory: function JWTAuthInterceptor_Factory() { return new JWTAuthInterceptor(i0.ɵɵinject(i1.Token)); }, token: JWTAuthInterceptor, providedIn: "root" });
    JWTAuthInterceptor = __decorate([
        Injectable({
            providedIn: 'root',
        })
    ], JWTAuthInterceptor);
    return JWTAuthInterceptor;
}());
export { JWTAuthInterceptor };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiand0LWF1dGguaW50ZXJjZXB0b3IuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AbnV2ZW0vYW5ndWxhci1iYXNlLyIsInNvdXJjZXMiOlsibGliL3NlY3VyaXR5L3Rva2VuL2p3dC1hdXRoLmludGVyY2VwdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQXdELFlBQVksRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRzFHLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JDLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxTQUFTLENBQUM7OztBQUVoQzs7O0dBR0c7QUFJSDtJQUVJOzs7O09BSUc7SUFDSCw0QkFBb0IsS0FBWTtRQUFaLFVBQUssR0FBTCxLQUFLLENBQU87SUFBRyxDQUFDO0lBRXBDOzs7Ozs7T0FNRztJQUNILHNDQUFTLEdBQVQsVUFBVSxPQUF5QixFQUFFLElBQWlCO1FBQXRELGlCQWNDO1FBYkcsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxFQUFFO1lBQ3ZCLE9BQU8sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQ2xEO1FBQ0QsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQzthQUN0QixJQUFJLENBQ0QsR0FBRyxDQUFDLFVBQUMsS0FBcUI7WUFDdEIsSUFBSSxLQUFLLFlBQVksWUFBWSxFQUFFO2dCQUMvQixJQUFNLEtBQUssR0FBVyxLQUFJLENBQUMsS0FBSyxDQUFDLHVCQUF1QixDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDeEUsSUFBSSxJQUFJLEtBQUssS0FBSztvQkFBRSxLQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUNwRDtZQUNELE9BQU8sS0FBSyxDQUFDO1FBQ2pCLENBQUMsQ0FBQyxDQUNMLENBQUM7SUFDVixDQUFDOztnQkF2QjBCLEtBQUs7OztJQVB2QixrQkFBa0I7UUFIOUIsVUFBVSxDQUFDO1lBQ1IsVUFBVSxFQUFFLE1BQU07U0FDckIsQ0FBQztPQUNXLGtCQUFrQixDQWdDOUI7NkJBOUNEO0NBOENDLEFBaENELElBZ0NDO1NBaENZLGtCQUFrQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEh0dHBFdmVudCwgSHR0cEhhbmRsZXIsIEh0dHBJbnRlcmNlcHRvciwgSHR0cFJlcXVlc3QsIEh0dHBSZXNwb25zZSB9IGZyb20gXCJAYW5ndWxhci9jb21tb24vaHR0cFwiO1xuXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSBcInJ4anNcIjtcbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVG9rZW4gfSBmcm9tIFwiLi90b2tlblwiO1xuXG4vKipcbiAqIEltcGxlbWVudGHDp8OjbyBkZSBjbGFzc2UgcGFyYSBpbnRlcmNlcHRhciBlIHRyYXRhciByZXF1aXNpw6fDtWVzIGh0dHAvaHR0cHNcbiAqIEBjbGFzc1xuICovXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBKV1RBdXRoSW50ZXJjZXB0b3IgaW1wbGVtZW50cyBIdHRwSW50ZXJjZXB0b3Ige1xuXG4gICAgLyoqXG4gICAgICogTWV0b2RvIGNvbnN0cnV0b3IgcmVzcG9uc8OhdmVsIHBvciBpbmpldGFyIHNlcnZpw6dvIGRlIGF1dGVudGljYcOnw6NvXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBYnN0cmFjdEF1dGhlbnRpY2F0aW9ufSBhdXRoXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSB0b2tlbjogVG9rZW4pIHt9XG5cbiAgICAvKipcbiAgICAgKiBNZXRvZG8gcmVzcG9uc8OhdmVsIHBvciBpbnRlcmNlcHRhciByZXF1aXNpw6fDtWVzIEhUVFAvSFRUUFNcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtIdHRwUmVxdWVzdDxhbnk+fSByZXF1ZXN0XG4gICAgICogQHBhcmFtIHtIdHRwSGFuZGxlcn0gbmV4dFxuICAgICAqIEByZXR1cm5zIE9ic2VydmFibGU8SHR0cEV2ZW50PGFueT4+XG4gICAgICovXG4gICAgaW50ZXJjZXB0KHJlcXVlc3Q6IEh0dHBSZXF1ZXN0PGFueT4sIG5leHQ6IEh0dHBIYW5kbGVyKTogT2JzZXJ2YWJsZTxIdHRwRXZlbnQ8YW55Pj4ge1xuICAgICAgICBpZiAodGhpcy50b2tlbi5oYXNUb2tlbigpKSB7XG4gICAgICAgICAgICByZXF1ZXN0ID0gdGhpcy50b2tlbi5zZXRUb2tlbkluSGVhZGVyKHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0LmhhbmRsZShyZXF1ZXN0KVxuICAgICAgICAgICAgLnBpcGUoXG4gICAgICAgICAgICAgICAgdGFwKChldmVudDogSHR0cEV2ZW50PGFueT4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgSHR0cFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbjogU3RyaW5nID0gdGhpcy50b2tlbi5leHRyYWN0VG9rZW5Gcm9tSGVhZGVycyhldmVudC5oZWFkZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9PSB0b2tlbikgdGhpcy50b2tlbi5zdG9yZVRva2VuKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgfVxuXG59XG4iXX0=