import { __decorate, __param } from 'tslib';
import { HttpResponse, HttpClient, HttpErrorResponse, HttpHeaders, HTTP_INTERCEPTORS, HttpClientModule } from '@angular/common/http';
import { ɵɵdefineInjectable, Injectable, ɵɵinject, Input, Component, NgModule, HostListener, Directive, ElementRef, TemplateRef, ViewContainerRef, InjectionToken, Inject, RendererFactory2, ErrorHandler, NgZone, Pipe, EventEmitter, Output, ChangeDetectorRef } from '@angular/core';
import { tap, filter, startWith, map } from 'rxjs/operators';
import { Subject, BehaviorSubject, ReplaySubject, Subscription } from 'rxjs';
import { CommonModule } from '@angular/common';
import { RouterModule } from '@angular/router';
import { NgControl, NG_VALUE_ACCESSOR, FormControl } from '@angular/forms';

/**
 * Class BlockUiService
 * @class
 */
let BlockUiService = class BlockUiService {
    /**
     * constructor method
     * @constructor
     */
    constructor() {
        /**
         * subject property
         * @private
         * @type {Subject<BlockUiStatus>}
         */
        this.subject = new Subject();
        /**
         * loaderStatus property
         * @public
         * @type {Observable}
         */
        this.loaderStatus = this.subject.asObservable();
    }
    /**
     * show methods
     * @returns void
     */
    show() {
        this.subject.next({ status: true });
    }
    /**
     * hide methods
     * @returns void
     */
    hide() {
        this.subject.next({ status: false });
    }
};
BlockUiService.ɵprov = ɵɵdefineInjectable({ factory: function BlockUiService_Factory() { return new BlockUiService(); }, token: BlockUiService, providedIn: "root" });
BlockUiService = __decorate([
    Injectable({
        providedIn: 'root'
    })
], BlockUiService);

/**
 * Class BlockUiInterceptor
 * @class
 */
let BlockUiInterceptor = class BlockUiInterceptor {
    /**
     * constructor method
     * @constructor
     * @param {BlockUiService} service
     */
    constructor(service) {
        this.service = service;
    }
    /**
     * intercept method
     * @public
     * @param {HttpRequest<any>} req
     * @param {HttpHandler} next
     * @return Observable<HttpEvent<any>>
     */
    intercept(req, next) {
        if (this.isMutation(req.method)) {
            this.service.show();
        }
        return next.handle(req).pipe(tap((event) => {
            if (event instanceof HttpResponse) {
                this.service.hide();
            }
        }, (err) => {
            this.service.hide();
        }));
    }
    /**
     * isMutation method
     * @private
     * @param {string} method
     * @return boolean
     */
    isMutation(method) {
        const mutationsMethods = [
            'DELETE',
            'PATCH',
            'POST',
            'PUT'
        ];
        return mutationsMethods.indexOf(method) !== -1;
    }
};
BlockUiInterceptor.ctorParameters = () => [
    { type: BlockUiService }
];
BlockUiInterceptor.ɵprov = ɵɵdefineInjectable({ factory: function BlockUiInterceptor_Factory() { return new BlockUiInterceptor(ɵɵinject(BlockUiService)); }, token: BlockUiInterceptor, providedIn: "root" });
BlockUiInterceptor = __decorate([
    Injectable({
        providedIn: 'root'
    })
], BlockUiInterceptor);

/**
 * Componente responsável por expor o seletor <app-version-tag></app-version-tag> para reuso
 * @class
 */
let VersionTagComponent = class VersionTagComponent {
    /**
     * Metodo executado ao carregar o componente responsável por carregar o arquivo 'package.json'
     * @return void
     */
    ngOnInit() {
    }
};
__decorate([
    Input()
], VersionTagComponent.prototype, "cssClass", void 0);
VersionTagComponent = __decorate([
    Component({
        selector: 'app-version-tag',
        template: "<span style=\"margin-left: 5px;\">\n    Vers\u00E3o: {{version}}\n</span>"
    })
], VersionTagComponent);

/**
 * O componente VersionTag exibe o atributo `version` do arquivo `package.json` do sistema,
 * com o intuito de informar o usuário a versão atual da aplicação. Inicialmente foi feito para
 * ser utilizado no rodapé das aplicações conforme o exemplo a seguir.
 * @module
 */
let VersionTagModule = class VersionTagModule {
};
VersionTagModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            RouterModule
        ],
        declarations: [
            VersionTagComponent
        ],
        exports: [
            VersionTagComponent
        ]
    })
], VersionTagModule);

/**
 * Classe abstrata para serviço de autenticação
 * @class
 */
class Authentication {
}

let LogoutDirective = class LogoutDirective {
    constructor(authenticationService) {
        this.authenticationService = authenticationService;
    }
    click() {
        this.authenticationService.logout();
    }
};
LogoutDirective.ctorParameters = () => [
    { type: Authentication }
];
__decorate([
    HostListener('click')
], LogoutDirective.prototype, "click", null);
LogoutDirective = __decorate([
    Directive({ selector: '[logout]' })
], LogoutDirective);

let UserDirective = class UserDirective {
    constructor(el, authenticationService) {
        this.el = el;
        this.authenticationService = authenticationService;
    }
    ngOnInit() {
        if (this.authenticationService.isAuthenticated()) {
            let user = this.authenticationService.getUser();
            this.el.nativeElement.innerHTML += this.user ? user[this.user] : user.name;
        }
    }
};
UserDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Authentication }
];
__decorate([
    Input()
], UserDirective.prototype, "user", void 0);
UserDirective = __decorate([
    Directive({ selector: '[user]' })
], UserDirective);

/**
 * Componente de login que será chamado quando a aplicação for logada com sucesso.
 * Deverá ser criada uma rota para esse componente.
 * @class
 */
let LoginSuccessComponent = class LoginSuccessComponent {
    constructor(authenticationService) {
        this.authenticationService = authenticationService;
    }
    ngOnInit() {
        this.authenticationService.login();
    }
};
LoginSuccessComponent.ctorParameters = () => [
    { type: Authentication }
];
LoginSuccessComponent = __decorate([
    Component({
        selector: 'app-login-success',
        template: ''
    })
], LoginSuccessComponent);

/**
 * Classe abstrata para serviço de autorização
 * @class
 */
class Authorization {
}

/**
 * HasRoleDirective diretiva para checagem da existência de permissões de acesso para o usuário logado.
 * @class
 */
let HasRoleDirective = class HasRoleDirective {
    /**
     * Método construtor responsável por carregar o serviço de autorização e serviço de identificação de mudança
     * @param {TemplateRef<any>} templateRef
     * @param {ViewContainerRef} viewContainer
     * @param {Authorization} authorization
     * @param {Authentication<User>} authentication
     */
    constructor(templateRef, viewContainer, authorization, authentication) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.authorization = authorization;
        this.authentication = authentication;
    }
    /**
     * Propriedade para identificar regras de acesso aos itens
     * @type {string}
     */
    set hasRole(hasRole) {
        this.viewContainer.clear();
        if (hasRole) {
            if (this.loginNotifications)
                this.loginNotifications.unsubscribe();
            this.loginNotifications = this.authentication.getLoginNotifications().subscribe(() => {
                if (this.authorization.hasRole(hasRole)) {
                    this.viewContainer.clear();
                    this.viewContainer.createEmbeddedView(this.templateRef);
                }
            });
        }
        else {
            this.viewContainer.createEmbeddedView(this.templateRef);
        }
    }
    ngOnDestroy() {
        this.loginNotifications.unsubscribe();
    }
};
HasRoleDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef },
    { type: Authorization },
    { type: Authentication }
];
__decorate([
    Input()
], HasRoleDirective.prototype, "hasRole", null);
HasRoleDirective = __decorate([
    Directive({
        selector: '[hasRole]'
    })
], HasRoleDirective);

/**
 *
 * Componente HideWhileLoginComponent, utilizado para não apresentar a tela da aplicação enquanto a fase de login não terminou.
 *
 * @class
 */
let HideWhileLoginComponent = class HideWhileLoginComponent {
    /**
     * constructor method
     * @param {ElementRef} hostComponent
     * @param {AbstractAuthentication} auth
     * @param {BlockUiService} blockUiService
     * @constructor
     */
    constructor(hostComponent, auth, blockUiService) {
        this.hostComponent = hostComponent;
        this.auth = auth;
        this.blockUiService = blockUiService;
        /**
         * Carrega conteúdo
         * @type {loadingString}
         */
        this.loadingContent = "";
        this.waitingLogin = false;
    }
    ngOnInit() {
        this.waitingLogin = !this.auth.isAuthenticated();
    }
    ngAfterContentInit() {
        if (!this.auth.isAuthenticated()) {
            this.blockUiService.show();
        }
    }
    ngAfterViewInit() {
        if (!this.auth.isAuthenticated()) {
            for (let i = 1; i < this.hostComponent.nativeElement.children.length; i++) {
                this.hostComponent.nativeElement.children[i].style.display = 'none';
            }
        }
        this.loginNotifications = this.auth.getLoginNotifications().subscribe(() => {
            for (let i = 1; i < this.hostComponent.nativeElement.children.length; i++) {
                this.hostComponent.nativeElement.children[i].style.display = 'inherit';
            }
            this.waitingLogin = false;
            this.blockUiService.hide();
        });
    }
    /**
     * ngOnDestroy method
     * @returns void
     */
    ngOnDestroy() {
        this.loginNotifications.unsubscribe();
    }
};
HideWhileLoginComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Authentication },
    { type: BlockUiService }
];
__decorate([
    Input()
], HideWhileLoginComponent.prototype, "loadingContent", void 0);
HideWhileLoginComponent = __decorate([
    Component({
        selector: '[hide-while-login]',
        template: "<span *ngIf=\"waitingLogin\">{{ loadingContent }}</span>\n<ng-content></ng-content>"
    })
], HideWhileLoginComponent);

/**
 * Constante de configuração
 * @const
 */
const AUTH_CONFIG = new InjectionToken('auth.config');

/**
 * Serviço de autorização
 * @class
 */
let AuthorizationService = class AuthorizationService extends Authorization {
    /**
     * Método construtor para a injeção do serviço de configuração AuthConfig
     * @constructor
     * @param {AuthConfig} config
     */
    constructor(authenticationService) {
        super();
        this.authenticationService = authenticationService;
    }
    /**
     * Método responsável por identificar as regras de acesso
     * @public
     * @param {any} role
     * @returns boolean
     */
    hasRole(role) {
        if (role) {
            const user = this.authenticationService.getUser();
            if (role instanceof Array) {
                return user.roles.some((userRole) => role.some((checkRole) => userRole === checkRole));
            }
            return user.roles.some((userRole) => userRole === role);
        }
        return true;
    }
};
AuthorizationService.ctorParameters = () => [
    { type: Authentication }
];
AuthorizationService.ɵprov = ɵɵdefineInjectable({ factory: function AuthorizationService_Factory() { return new AuthorizationService(ɵɵinject(Authentication)); }, token: AuthorizationService, providedIn: "root" });
AuthorizationService = __decorate([
    Injectable({
        providedIn: 'root',
    })
], AuthorizationService);

function isAuthenticated(config) {
    return null !== config.storage.getItem(config.userStorageIndex);
}
;
function redirect(config) {
    window.location.href = config.loginUrl;
    ;
}
;
/**
 * Serviço de autenticação
 * @class
 */
let AuthenticationService = class AuthenticationService extends Authentication {
    constructor(config, http) {
        super();
        this.config = config;
        this.http = http;
        this.loginNotifications = new BehaviorSubject(this.getUser());
    }
    /**
     * Método para verificar se o usuário esta autenticado na aplicação
     * @returns boolean
     * @public
     */
    isAuthenticated() {
        return isAuthenticated(this.config);
    }
    /**
     * Método responsável por realizar redirecionamentos
     * @returns void
     * @public
     */
    redirect() {
        redirect(this.config);
    }
    /**
     * Método responsável pelo login da aplicação
     * @public
     * @param {User} user
     * @returns Observable<any>
     */
    login() {
        this.getUserDetails()
            .subscribe((user) => {
            this.setUser(user);
            this.loginNotifications.next(user);
        });
    }
    /**
     * Método responsável pelo logou da aplicação
     * @public
     * @returns void
     */
    logout() {
        this.loginNotifications.next(null);
        this.config.storage.removeItem(this.config.userStorageIndex);
        window.location.href = this.config.logoutUrl;
    }
    /**
     * Método responsável por obter os dados do usuário logado
     * @public
     * @returns Observable<any>
     */
    getUserDetails() {
        return this.http.get(this.config.baseUrl + this.config.detailsUrl);
    }
    setUser(user) {
        this.config.storage.setItem(this.config.userStorageIndex, JSON.stringify(user));
    }
    getUser() {
        return JSON.parse(this.config.storage.getItem(this.config.userStorageIndex));
    }
    getLoginNotifications() {
        return this.loginNotifications.pipe(filter((value) => value != null));
    }
};
AuthenticationService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [AUTH_CONFIG,] }] },
    { type: HttpClient }
];
AuthenticationService.ɵprov = ɵɵdefineInjectable({ factory: function AuthenticationService_Factory() { return new AuthenticationService(ɵɵinject(AUTH_CONFIG), ɵɵinject(HttpClient)); }, token: AuthenticationService, providedIn: "root" });
AuthenticationService = __decorate([
    Injectable({
        providedIn: 'root',
    }),
    __param(0, Inject(AUTH_CONFIG))
], AuthenticationService);

/**
 * Provedor de error para criação de erros de notificação.
 * @class
 */
let NotAuthenticatedErrorProvider = class NotAuthenticatedErrorProvider {
    constructor(authenticationService) {
        this.authenticationService = authenticationService;
    }
    /**
     * Método para identificar se o usuário está logado
     * @public
     * @param {HttpErrorResponse} error
     * @returns void
     */
    shouldHandle(error) {
        return error instanceof HttpErrorResponse && error.status == 401;
    }
    /**
     * Método para redirecionar caso o usuário não esteja
     * @public
     * @param {HttpErrorResponse} error
     * @returns void
     */
    handle(error) {
        this.authenticationService.redirect();
    }
};
NotAuthenticatedErrorProvider.ctorParameters = () => [
    { type: Authentication }
];
NotAuthenticatedErrorProvider.ɵprov = ɵɵdefineInjectable({ factory: function NotAuthenticatedErrorProvider_Factory() { return new NotAuthenticatedErrorProvider(ɵɵinject(Authentication)); }, token: NotAuthenticatedErrorProvider, providedIn: "root" });
NotAuthenticatedErrorProvider = __decorate([
    Injectable({
        providedIn: 'root',
    })
], NotAuthenticatedErrorProvider);

/**
 * Anstract class ErrorProvider
 * @class
 * @abstract
 */
class ErrorProvider {
}

/**
 * Classe abstrata para gerencia de tokens
 * @class
 */
class Token {
}

/**
 * Implementação de classe para interceptar e tratar requisições http/https
 * @class
 */
let JWTAuthInterceptor = class JWTAuthInterceptor {
    /**
     * Metodo construtor responsável por injetar serviço de autenticação
     * @constructor
     * @param {AbstractAuthentication} auth
     */
    constructor(token) {
        this.token = token;
    }
    /**
     * Metodo responsável por interceptar requisições HTTP/HTTPS
     * @public
     * @param {HttpRequest<any>} request
     * @param {HttpHandler} next
     * @returns Observable<HttpEvent<any>>
     */
    intercept(request, next) {
        if (this.token.hasToken()) {
            request = this.token.setTokenInHeader(request);
        }
        return next.handle(request)
            .pipe(tap((event) => {
            if (event instanceof HttpResponse) {
                const token = this.token.extractTokenFromHeaders(event.headers);
                if (null !== token)
                    this.token.storeToken(token);
            }
            return event;
        }));
    }
};
JWTAuthInterceptor.ctorParameters = () => [
    { type: Token }
];
JWTAuthInterceptor.ɵprov = ɵɵdefineInjectable({ factory: function JWTAuthInterceptor_Factory() { return new JWTAuthInterceptor(ɵɵinject(Token)); }, token: JWTAuthInterceptor, providedIn: "root" });
JWTAuthInterceptor = __decorate([
    Injectable({
        providedIn: 'root',
    })
], JWTAuthInterceptor);

var JWTTokenService_1;
/**
 * Inplementação de serviço JWTTokenService
 * @class
 */
let JWTTokenService = JWTTokenService_1 = class JWTTokenService extends Token {
    /**
     * Metodo construtor responsável por injetar as configurações de autenticação
     * @constructor
     * @param {AuthConfig} config
     */
    constructor(config) {
        super();
        this.config = config;
    }
    /**
     * Metodo responsável pela extração de tokes do heaedrs das requisições
     * @public
     * @param {HttpHeaders} headers
     * @returns string
     */
    extractTokenFromHeaders(headers) {
        return headers.get(JWTTokenService_1.HEADER_STRING);
    }
    /**
     * Metodo responsável pela adição dos tokens no storage
     * @public
     * @param {String} token
     * @returns void
     */
    storeToken(token) {
        this.config.storage.setItem(this.config.tokenStorageIndex, token.toString());
    }
    /**
     * Metodo responsável por injetar token no header das requisições
     * @public
     * @param {HttpRequest<any>} request
     * @returns HttpRequest<any>
     */
    setTokenInHeader(request) {
        const req = request.clone({
            headers: new HttpHeaders({
                [JWTTokenService_1.HEADER_STRING]: this.config.storage.getItem(this.config.tokenStorageIndex)
            })
        });
        return req;
    }
    /**
     * Metodo responsável por verificar a existencia de um token de autenticação
     * @returns boolean
     * @public
     */
    hasToken() {
        return null !== this.config.storage.getItem(this.config.tokenStorageIndex);
    }
};
/**
 * TOKEN_PREFIX  property
 * @type {string}
 */
JWTTokenService.TOKEN_PREFIX = "Bearer";
/**
 * HEADER_STRING property
 * @type {string}
 */
JWTTokenService.HEADER_STRING = "Authorization";
JWTTokenService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [AUTH_CONFIG,] }] }
];
JWTTokenService.ɵprov = ɵɵdefineInjectable({ factory: function JWTTokenService_Factory() { return new JWTTokenService(ɵɵinject(AUTH_CONFIG)); }, token: JWTTokenService, providedIn: "root" });
JWTTokenService = JWTTokenService_1 = __decorate([
    Injectable({
        providedIn: 'root',
    }),
    __param(0, Inject(AUTH_CONFIG))
], JWTTokenService);

var SecurityModule_1;
/**
 * O modulo de segurança contem funcionalidades para autenticação, autorização, redirecionamento
 * para login, gerenciamento de tokens JWT e obtenção e armazenamento de dados de usuário.
 * @class
 */
let SecurityModule = SecurityModule_1 = class SecurityModule {
    /**
     * forRoot method
     * @public
     * @static
     * @returns ModuleWithProviders
     */
    static forRoot(config) {
        return {
            ngModule: SecurityModule_1,
            providers: [
                { provide: AUTH_CONFIG, useValue: config },
                config.tokenStorageIndex ?
                    [
                        { provide: Token, useClass: JWTTokenService },
                        { provide: HTTP_INTERCEPTORS, useClass: JWTAuthInterceptor, multi: true }
                    ] : []
            ]
        };
    }
};
SecurityModule = SecurityModule_1 = __decorate([
    NgModule({
        imports: [
            CommonModule,
            RouterModule,
            HttpClientModule
        ],
        declarations: [
            LogoutDirective,
            UserDirective,
            LoginSuccessComponent,
            HasRoleDirective,
            HideWhileLoginComponent
        ],
        providers: [
            AuthorizationService,
            AuthenticationService,
            { provide: ErrorProvider, useClass: NotAuthenticatedErrorProvider, multi: true },
            { provide: Authorization, useClass: AuthorizationService },
            { provide: Authentication, useClass: AuthenticationService }
        ],
        exports: [
            LogoutDirective,
            UserDirective,
            LoginSuccessComponent,
            HasRoleDirective,
            HideWhileLoginComponent
        ]
    })
], SecurityModule);

/**
 * Guard que verifica se usuário está autenticado antes do usuário acessar uma rota.
 * Se for verificar que o usuário não está autenticado, é feito um redirecionamento para o login.
 * @class
 */
let AuthGuard = class AuthGuard {
    /**
     * Método construtor responsável pela injeção do serviço de autenticação
     * @constructor
     * @param {Authentication} auth
     */
    constructor(authenticationService) {
        this.authenticationService = authenticationService;
    }
    /**
     * Método responsável por identificar se o usuário está autenticado
     * @public
     * @param {ActivatedRouteSnapshot} route
     * @param {RouterStateSnapshot} state
     * @returns boolean
     */
    canActivate(route, state) {
        if (this.authenticationService.isAuthenticated()) {
            return true;
        }
        this.authenticationService.redirect();
        return false;
    }
    /**
     * Método responsável por atuar somente em rotas filhas de modo independente
     * @public
     * @param {ActivatedRouteSnapshot} route
     * @param {RouterStateSnapshot} state
     * @returns boolean
     */
    canActivateChild(route, state) {
        return this.canActivate(route, state);
    }
};
AuthGuard.ctorParameters = () => [
    { type: Authentication }
];
AuthGuard.ɵprov = ɵɵdefineInjectable({ factory: function AuthGuard_Factory() { return new AuthGuard(ɵɵinject(Authentication)); }, token: AuthGuard, providedIn: "root" });
AuthGuard = __decorate([
    Injectable({
        providedIn: 'root',
    })
], AuthGuard);

function bootstrapSecurity(config, authenticated, isAuthenticated$1 = isAuthenticated, notAuthenticated = redirect) {
    if (window.location.href.includes(config.loginSuccessRoute) || isAuthenticated$1(config)) {
        authenticated();
    }
    else {
        notAuthenticated(config);
    }
}

/**
 * AccessbilityService Serviço de acessibilidade, este serviço prove recursos de contraste
 * de tela e controle do tamanho da fonte apresentadas na tela.
 * @class
 */
let AccessbilityService = class AccessbilityService {
    constructor(rendererFactory) {
        /**
         * Propriedade que define tamanho da fonte
         * @type {number}
         */
        this.fontSize = 1.0;
        this.renderer = rendererFactory.createRenderer(null, null);
    }
    /**
     * Medoto para habilitar contraste
     * @public
     * @returns void
     */
    enableHighContrast() {
        this.renderer.addClass(document.body, 'contraste');
    }
    /**
     * Metodo para desabilitar contraste
     * @public
     * @returns void
     */
    disableHighContrast() {
        this.renderer.removeClass(document.body, 'contraste');
    }
    /**
     * Metodo utilizado para aumentar o tamnho da fonte apresentada no display
     * @public
     * @returns void
     */
    increaseFontSize() {
        this.fontSize += 0.1;
        this.renderer.setStyle(document.querySelector('div.layout-wrapper'), 'font-size', this.fontSize + 'em');
    }
    /**
     * Metodo utilizado para diminuir o tamnho da fonte apresentada no display
     * @public
     * @returns void
     */
    decreaseFontSize() {
        this.fontSize -= 0.1;
        this.renderer.setStyle(document.querySelector('div.layout-wrapper'), 'font-size', this.fontSize + 'em');
    }
    addAccessibilityIcons() {
        const elements = document.querySelector('.ui-button-icon-left, ui-button-icon-righ');
        if (elements) {
            this.renderer.setStyle(elements, 'aria-hidden', true);
        }
    }
    addAccessibilityMessages(msg) {
        let type = 'polite';
        if (msg.severity.toLowerCase() !== 'custom' && msg.severity.toLowerCase() !== 'success') {
            type = 'assertive';
        }
        this.renderer.setStyle(document.querySelector('p-toast, p-growl'), 'aria-live', type);
    }
};
AccessbilityService.ctorParameters = () => [
    { type: RendererFactory2 }
];
AccessbilityService.ɵprov = ɵɵdefineInjectable({ factory: function AccessbilityService_Factory() { return new AccessbilityService(ɵɵinject(RendererFactory2)); }, token: AccessbilityService, providedIn: "root" });
AccessbilityService = __decorate([
    Injectable({
        providedIn: 'root',
    })
], AccessbilityService);

/**
 * AccessbilityModule expõe o servico AccessbilityService para o uso de outras aplicações
 * @module
 */
let AccessbilityModule = class AccessbilityModule {
};
AccessbilityModule = __decorate([
    NgModule({
        imports: [CommonModule],
        providers: [AccessbilityService],
        exports: []
    })
], AccessbilityModule);

/**
 *
 * Class CommonMaskService serviço para inserção de mascara de data em campos input
 * @class
 */
let CommonMaskService = class CommonMaskService {
    constructor() {
        /**
         * DATE_SEPARATOR property
         * @type {string}
         */
        this.DATE_SEPARATOR = '/';
    }
    /**
     * Metodo para formatar valor digitado no padrão dd/mm/yyyy
     * @param $event
     * @returns void
     */
    dateMask($event) {
        if ($event.target.value) {
            let date = $event.target.value.replace(/[^0-9]/g, '').substr(0, 8);
            if (date.length >= 3) {
                date = date.replace(/^(\d{2})(\d{1,2})/, '$1' + this.DATE_SEPARATOR + '$2');
            }
            if (date.length >= 6) {
                date = date.replace(/^(\S{5})(\d{1,4})/, '$1' + this.DATE_SEPARATOR + '$2');
            }
            $event.target.value = date;
        }
    }
};
CommonMaskService.ɵprov = ɵɵdefineInjectable({ factory: function CommonMaskService_Factory() { return new CommonMaskService(); }, token: CommonMaskService, providedIn: "root" });
CommonMaskService = __decorate([
    Injectable({
        providedIn: 'root',
    })
], CommonMaskService);

/**
 * CommonMaskModule expõe o servico CommonMaskService para o uso de outras aplicações
 * @class
 */
let CommonMaskModule = class CommonMaskModule {
};
CommonMaskModule = __decorate([
    NgModule({
        imports: [],
        declarations: [],
        providers: [
            CommonMaskService
        ],
        exports: []
    })
], CommonMaskModule);

/**
 * Class ErrorService
 * @class
 */
let ErrorService = class ErrorService extends ErrorHandler {
    /**
     * Metodo construtor responável por injetar o serviço ErrorProvider
     * @param {ErrorProvider} providers
     */
    constructor(providers) {
        super();
        this.providers = providers;
    }
    /**
     * Metodo responsável por idetificar e obter os erros lançados de requisições http/https
     * @param {Error} error
     * @returns void
     */
    handleError(error) {
        try {
            this.providers.forEach(p => {
                if (p.shouldHandle(error)) {
                    p.handle(error);
                }
            });
        }
        catch (e) {
        }
        super.handleError(error);
    }
};
ErrorService.ctorParameters = () => [
    { type: Array, decorators: [{ type: Inject, args: [ErrorProvider,] }] }
];
ErrorService.ɵprov = ɵɵdefineInjectable({ factory: function ErrorService_Factory() { return new ErrorService(ɵɵinject(ErrorProvider)); }, token: ErrorService, providedIn: "root" });
ErrorService = __decorate([
    Injectable({
        providedIn: 'root',
    }),
    __param(0, Inject(ErrorProvider))
], ErrorService);

/**
 * Abstract provider NotificationProvider
 * @abstract
 * @class
 */
class NotificationProvider {
}

/**
 * Classe modelo ApplicationProblemType
 * @class
 */
class ApplicationProblemType {
    /**
     * constructor method
     * @param {string} type
     * @param {string} title
     * @param {string} detail
     * @param {Number} status
     * @param {string} instance
     * @param {Array<string>} stacktrace
     * @param {ApplicationProblemType} cause
     * @constructor
     */
    constructor(type, title, detail, status, instance, stacktrace, cause) {
        this.type = type;
        this.title = title;
        this.detail = detail;
        this.status = status;
        this.instance = instance;
        this.stacktrace = stacktrace;
        this.cause = cause;
    }
}

/**
 * Serviço HttpApplicationProblemErrorService
 * @class
 */
let HttpApplicationProblemErrorService = class HttpApplicationProblemErrorService {
    /**
     * Metodo construtor responsável por injetar serviço NotificationProvider
     * @param {NotificationProvider} notification
     * @constructor
     */
    constructor(notification, ngZone) {
        this.notification = notification;
        this.ngZone = ngZone;
    }
    /**
     * Metodo responsável pela identificação de erros
     * @public
     * @param {Error | HttpErrorResponse} error
     * @returns Boolean
     */
    shouldHandle(error) {
        return error instanceof HttpErrorResponse &&
            error.headers.get('Content-Type') === 'application/problem+json' &&
            error.error;
    }
    /**
     * Metodo pela adição de erros
     * @public
     * @param {HttpErrorResponse} error
     * @returns void
     */
    handle(error) {
        this.ngZone.run(() => {
            this.notification.addErrorProblem(new ApplicationProblemType(error.error.type, error.error.title, error.error.detail, error.error.status, error.error.instance));
        });
    }
};
HttpApplicationProblemErrorService.ctorParameters = () => [
    { type: NotificationProvider },
    { type: NgZone }
];
HttpApplicationProblemErrorService.ɵprov = ɵɵdefineInjectable({ factory: function HttpApplicationProblemErrorService_Factory() { return new HttpApplicationProblemErrorService(ɵɵinject(NotificationProvider), ɵɵinject(NgZone)); }, token: HttpApplicationProblemErrorService, providedIn: "root" });
HttpApplicationProblemErrorService = __decorate([
    Injectable({
        providedIn: 'root',
    })
], HttpApplicationProblemErrorService);

/**
 * Classe modelo HttpGenericErrorType
 * @class
 */
class HttpGenericErrorType {
    /**
     * constructor method
     * @param {Number} code
     * @param {string} title
     * @param {string} detail
     * @constructor
     */
    constructor(code, title, detail) {
        this.code = code;
        this.title = title;
        this.detail = detail;
    }
}

/**
 * Serviço HttpGenericErrorService
 * @class
 */
let HttpGenericErrorService = class HttpGenericErrorService {
    /**
     * Metodo construtor responsávelpor injetar o serviço NotificationProvider
     * @param {NotificationProvider} notification
     * @constructor
     */
    constructor(notification, ngZone) {
        this.notification = notification;
        this.ngZone = ngZone;
    }
    /**
     * Metodo responsável pela identificação de erros
     * @public
     * @param {Error | HttpErrorResponse} error
     * @returns Boolean
     */
    shouldHandle(error) {
        return error instanceof HttpErrorResponse &&
            !(error.headers.get('Content-Type') === 'application/problem+json' &&
                error.error);
    }
    /**
     * Metodo pela adição de erros
     * @public
     * @param {HttpErrorResponse} error
     * @returns void
     */
    handle(error) {
        const generic = this.getErrorByCode(error);
        this.ngZone.run(() => {
            this.notification.addErrorMessage(generic.detail, generic.title);
        });
    }
    /**
     * Metodo para obter erros a partir de um código
     * @public
     * @param {HttpErrorResponse} error
     * @returns HttpGenericErrorType
     */
    getErrorByCode(error) {
        const generic = GENERIC_ERRORS[error.status];
        if (generic === undefined) {
            return new HttpGenericErrorType(error.status, error.statusText, error.message);
        }
        return generic;
    }
};
HttpGenericErrorService.ctorParameters = () => [
    { type: NotificationProvider },
    { type: NgZone }
];
HttpGenericErrorService.ɵprov = ɵɵdefineInjectable({ factory: function HttpGenericErrorService_Factory() { return new HttpGenericErrorService(ɵɵinject(NotificationProvider), ɵɵinject(NgZone)); }, token: HttpGenericErrorService, providedIn: "root" });
HttpGenericErrorService = __decorate([
    Injectable({
        providedIn: 'root',
    })
], HttpGenericErrorService);
/**
 * Constante que define tipos de erros básicos
 * @const GENERIC_ERRORS
 */
const GENERIC_ERRORS = {
    401: new HttpGenericErrorType(401, 'Não Autenticado', 'Essa requisição requer um usuário autenticado.'),
    403: new HttpGenericErrorType(403, 'Proibido', 'Essa requisição requer uma permissão no servidor da aplicação que o usuário não possui.'),
    404: new HttpGenericErrorType(404, 'Não encontrado', 'Essa requisição não pode ser encontrada.'),
    500: new HttpGenericErrorType(500, 'Erro desconhecido', 'O servidor encontrou uma condição inesperada.'),
    502: new HttpGenericErrorType(502, 'Bad Gateway', 'O servidor recebeu uma resposta inválida de um serviço que utilizou para cumprir a requisição'),
    503: new HttpGenericErrorType(503, 'Serviço Indisponível', 'O servidor não pode atender a requisição nesse momento. Esta é uma condição temporária, tente novamente mais tarde'),
    504: new HttpGenericErrorType(504, 'Gateway Timeout', 'O servidor não conseguiu receber uma resposta a tempo esperado por um serviço que utilizou para cumprir a requisição')
};

/**
 * O modulo ErrorModule contem funcionalidades para a captura e apresentação dos erros que possam ocorrer na aplicação.
 * @module
 */
let ErrorModule = class ErrorModule {
};
ErrorModule = __decorate([
    NgModule({
        declarations: [],
        imports: [
            CommonModule
        ],
        providers: [
            {
                provide: ErrorProvider,
                useClass: HttpGenericErrorService,
                multi: true
            },
            {
                provide: ErrorProvider,
                useClass: HttpApplicationProblemErrorService,
                multi: true
            },
            {
                provide: ErrorHandler,
                useClass: ErrorService,
            },
        ]
    })
], ErrorModule);

/**
 * Class NotificationService
 * @class
 */
let NotificationService = class NotificationService extends NotificationProvider {
    /**
     * Metodo responsável po adicionar mensagem de erro
     * @param {string} message
     * @param {string} title
     * @returns void
     */
    addErrorMessage(message, title) {
        console.error(title + ' ' + message);
    }
    /**
     * Metodo responsável por adicionar o detalhamento do erro no console
     * @param {ApplicationProblemType} problem
     * @returns void
     */
    addErrorProblem(problem) {
        console.error(problem.title + ' ' + problem.detail);
    }
};
NotificationService.ɵprov = ɵɵdefineInjectable({ factory: function NotificationService_Factory() { return new NotificationService(); }, token: NotificationService, providedIn: "root" });
NotificationService = __decorate([
    Injectable({
        providedIn: 'root',
    })
], NotificationService);

/**
 * Serviço de erros ErrorStackService
 * @class
 */
let ErrorStackService = class ErrorStackService {
    /**
     * metodo construtor injeta serviço generico de erros
     * @param {HttpGenericErrorService} genericErrorService
     * @constructor
     */
    constructor(genericErrorService) {
        this.genericErrorService = genericErrorService;
        /**
         * Propriedade errors
         * @type {ReplaySubject<NamedErrorType>}
         */
        this.errors = new ReplaySubject();
        if (null === localStorage.getItem('errorStack')) {
            localStorage.setItem('errorStack', JSON.stringify([]));
        }
        this.getErrorsSubjects().forEach((error) => {
            this.errors.next(error);
        });
    }
    /**
     * Metodo responsável por criar erro do tipo HttpResponse
     * @param {HttpErrorResponse} error
     * @returns void
     */
    create(error) {
        const namedError = this.createNamedError(error);
        const persistedErrors = this.getErrorsSubjects();
        if (persistedErrors.length >= 15) {
            persistedErrors.shift();
        }
        persistedErrors.push(namedError);
        localStorage.setItem('errorStack', JSON.stringify(persistedErrors));
        this.errors.next(namedError);
    }
    /**
     * Metodo responsável por obter o conteúdo dos erros emitidos
     * @private
     * @returns NamedErrorType[]
     */
    getErrorsSubjects() {
        return JSON.parse(localStorage.getItem('errorStack'));
    }
    /**
     * Metodo responsável por itentifica o tipo de erro lançado
     * @private
     * @param {HttpErrorResponse} error
     * @returns NamedErrorType
     */
    createNamedError(error) {
        let fullMessage;
        let namedError;
        let createdAt = new Date();
        let errorId = this.getErrorId(error);
        let title;
        if (error.headers.get('Content-Type') === 'application/problem+json') {
            fullMessage = `X-Correlation-ID: ${errorId}
                           createdAt: ${createdAt}
                           status: ${error.status}
                           url: ${error.url}
                           body: ${error.error.detail}
                           stacktrace: ${error.error.stacktrace}
                           cause: ${error.error.cause}`;
            title = error.error.title;
        }
        else {
            const genericError = this.genericErrorService.getErrorByCode(error);
            fullMessage = `X-Correlation-ID: ${errorId}
                           createdAt: ${createdAt}
                           status: ${error.status}
                           url: ${error.url}
                           body: ${genericError.detail}`;
            title = genericError.title;
        }
        namedError = {
            message: title,
            createdAt: createdAt,
            correlationId: errorId,
            fullMessage: fullMessage
        };
        return namedError;
    }
    /**
     * Metodo responsável por obter o identificador do erro
     * @private
     * @param {HttpErrorResponse} error
     * @returns string
     */
    getErrorId(error) {
        let errorKey;
        error.headers.keys().every(key => {
            if (key.toUpperCase() === 'X-CORRELATION-ID') {
                errorKey = key;
                return false;
            }
            return true;
        });
        return errorKey ? error.headers.get(errorKey) : null;
    }
};
ErrorStackService.ctorParameters = () => [
    { type: HttpGenericErrorService }
];
ErrorStackService.ɵprov = ɵɵdefineInjectable({ factory: function ErrorStackService_Factory() { return new ErrorStackService(ɵɵinject(HttpGenericErrorService)); }, token: ErrorStackService, providedIn: "root" });
ErrorStackService = __decorate([
    Injectable({
        providedIn: 'root',
    })
], ErrorStackService);

/**
 * Class ErrorStackProviderService
 * @class
 */
let ErrorStackProviderService = class ErrorStackProviderService {
    /**
     * Metodo construtor responsável por injetar o serviso de erros
     * @param {ErrorStackService} errorStackService
     */
    constructor(errorStackService) {
        this.errorStackService = errorStackService;
    }
    /**
     * Metodo responsável pela identificação de erros
     * @param {Error} error
     * @returns Boolean
     */
    shouldHandle(error) {
        return error instanceof HttpErrorResponse;
    }
    /**
     * Metodo pela adição de erros
     * @param {HttpErrorResponse} error
     * @returns void
     */
    handle(error) {
        this.errorStackService.create(error);
    }
};
ErrorStackProviderService.ctorParameters = () => [
    { type: ErrorStackService }
];
ErrorStackProviderService.ɵprov = ɵɵdefineInjectable({ factory: function ErrorStackProviderService_Factory() { return new ErrorStackProviderService(ɵɵinject(ErrorStackService)); }, token: ErrorStackProviderService, providedIn: "root" });
ErrorStackProviderService = __decorate([
    Injectable({
        providedIn: 'root',
    })
], ErrorStackProviderService);

/**
 *
 * Cria PIPE de CEP para valores.
 *
 * Usage:
 * {{ value | cep }}
*/
let CepPipe = class CepPipe {
    transform(value) {
        if (value === null) {
            return '-';
        }
        else {
            value = value.replace(/[^0-9A-Za-z]/g, '');
            return value.substring(0, 5) + '-' + value.substring(5, 8);
        }
    }
};
CepPipe = __decorate([
    Pipe({
        name: 'cep'
    })
], CepPipe);

/**
 *
 * Cria PIPE de CPF para valores.
 *
 * Usage:
 * {{ value | cpf }}
*/
let CpfPipe = class CpfPipe {
    transform(value) {
        if (value === null || value.length !== 11) {
            return value;
        }
        else {
            value = value.replace(/[^0-9A-Za-z]/g, '');
            return value.substring(0, 3) + '.' +
                value.substring(3, 6) + '.' +
                value.substring(6, 9) + '-' +
                value.substring(9, 11);
        }
    }
};
CpfPipe = __decorate([
    Pipe({
        name: 'cpf'
    })
], CpfPipe);

/**
 *
 * Cria PIPE de CNPJ para valores.
 *
 * Usage:
 * {{ value | cnpj }}
*/
let CnpjPipe = class CnpjPipe {
    transform(value) {
        if (value === null || value.length !== 14) {
            return value;
        }
        else {
            value = value.replace(/[^0-9A-Za-z]/g, '');
            return value.substring(0, 2) + '.' +
                value.substring(2, 5) + '.' +
                value.substring(5, 8) + '/' +
                value.substring(8, 12) + '-' +
                value.substring(12, 14);
        }
    }
};
CnpjPipe = __decorate([
    Pipe({
        name: 'cnpj'
    })
], CnpjPipe);

/**
 *
 * Cria PIPE de valores com regra definida em expressão regex
 * Usage:
 * {{ value | regex:arg1:arg2 }}
*/
let RegexPipe = class RegexPipe {
    transform(value, regex, regexPrint) {
        return value.replace(regex, regexPrint);
    }
};
RegexPipe = __decorate([
    Pipe({
        name: 'regex'
    })
], RegexPipe);

/**
 *
 * Cria PIPE para valores com restrição de valores a serem apresentados.
 *
 * Usage:
 * {{ value | limit:20 }}
 * {{ value | limit:20:"..." }}
*/
let LimitPipe = class LimitPipe {
    transform(value, limit = 25, ellipsis = '...') {
        return value.length > limit
            ? `${value.substr(0, limit)}${ellipsis}`
            : value;
    }
};
LimitPipe = __decorate([
    Pipe({
        name: 'limit'
    })
], LimitPipe);

/**
 *
 *  Export do módulo
 */
let PipeModule = class PipeModule {
};
PipeModule = __decorate([
    NgModule({
        imports: [],
        declarations: [
            CepPipe,
            CpfPipe,
            CnpjPipe,
            RegexPipe,
            LimitPipe,
        ],
        exports: [
            CepPipe,
            CpfPipe,
            CnpjPipe,
            RegexPipe,
            LimitPipe,
        ]
    })
], PipeModule);

/**
 * Fornece metodo para copia de textos
 * @class
 */
let ClipboardService = class ClipboardService {
    /**
     * Inspirado no clipboard.js, copia texto selecionado para área de trasferência
     * @param {string} text
     * @returns void
     * @public
     */
    copy(text) {
        const isRTL = document.documentElement.getAttribute('dir') === 'rtl';
        // cria um elemento temporário, seta o foco, copia e remove em seguida
        let fake = document.createElement('textarea');
        fake.style.fontSize = '12pt';
        fake.style.border = '0';
        fake.style.padding = '0';
        fake.style.margin = '0';
        fake.style.position = 'absolute';
        fake.style[isRTL ? 'right' : 'left'] = '-9999px';
        let yPosition = window.pageYOffset || document.documentElement.scrollTop;
        fake.style.top = `${yPosition}px`;
        fake.setAttribute('readonly', '');
        fake.value = text;
        document.body.appendChild(fake);
        fake.select();
        document.execCommand('copy');
        document.body.removeChild(fake);
    }
};
ClipboardService.ɵprov = ɵɵdefineInjectable({ factory: function ClipboardService_Factory() { return new ClipboardService(); }, token: ClipboardService, providedIn: "root" });
ClipboardService = __decorate([
    Injectable({
        providedIn: 'root',
    })
], ClipboardService);

let ClipboardDirective = 
/**
 * Diretiva que expõe seletor para o uso do clipbord
 * @class
 */
class ClipboardDirective {
    /**
     * constructor method
     * @param {ClipboardService} service
     * @constructor
     */
    constructor(service) {
        this.service = service;
        /**
         * onClipboard variable
         * @type {EventEmitter<boolean>}
         */
        this.onClipboard = new EventEmitter();
    }
    /**
     * copy method
     * @event click
     * @returns void
     */
    copy() {
        try {
            this.service.copy(this.clipboard);
            this.onClipboard.emit(true);
        }
        catch (e) {
            this.onClipboard.emit(false);
            throw e;
        }
    }
};
ClipboardDirective.ctorParameters = () => [
    { type: ClipboardService }
];
__decorate([
    Input()
], ClipboardDirective.prototype, "clipboard", void 0);
__decorate([
    Output()
], ClipboardDirective.prototype, "onClipboard", void 0);
__decorate([
    HostListener('click')
], ClipboardDirective.prototype, "copy", null);
ClipboardDirective = __decorate([
    Directive({
        selector: '[clipboard]'
    })
    /**
     * Diretiva que expõe seletor para o uso do clipbord
     * @class
     */
], ClipboardDirective);

/**
 * ClipboardModule expõe o servico ClipboardService para o uso de outras aplicações
 * @module
 */
let ClipboardModule = class ClipboardModule {
};
ClipboardModule = __decorate([
    NgModule({
        imports: [],
        declarations: [
            ClipboardDirective,
        ],
        providers: [
            ClipboardService
        ],
        exports: [
            ClipboardDirective,
        ]
    })
], ClipboardModule);

/**
 *
 * UnmaskDirective diretiva para remoção de mascaras de valores numericos
 * @class
 */
let UnmaskDirective = class UnmaskDirective {
    /**
     * constructor method
     * @param {ElementRef} elementRef
     * @param {NgControl} model
     * @constructor
     */
    constructor(elementRef, model) {
        this.elementRef = elementRef;
        this.model = model;
    }
    /**
     * Metodo executado no carregamento da diretiva, executa verificação do valor e remove as mascaras baseado em um aexpressão regular
     * @returns void
     */
    ngOnInit() {
        this.subscriber = this.model.control.valueChanges.subscribe(() => {
            const newValue = this.elementRef.nativeElement.value.replace(new RegExp(this.appUnmask), '');
            this.model.control.setValue(newValue, {
                emitEvent: false,
                emitModelToViewChange: false,
                emitViewToModelChange: false
            });
        });
    }
    /**
     * ngOnDestroy method
     * @returns void
     */
    ngOnDestroy() {
        this.subscriber.unsubscribe();
    }
};
UnmaskDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgControl }
];
__decorate([
    Input()
], UnmaskDirective.prototype, "appUnmask", void 0);
UnmaskDirective = __decorate([
    Directive({
        selector: '[unmask]'
    })
], UnmaskDirective);

/**
 * OnlyNumbersDirective diretiva para que sejam permitidos somente números
 * @class
 */
let OnlyNumbersDirective = class OnlyNumbersDirective {
    /**
     * @param {ElementRef} el
     * @constructor
     */
    constructor(el) {
        this.el = el;
        /**
         * Propriedade que carrega expressão regular para numeros
         * @type {RegExp}
         */
        this.regex = new RegExp(/[^0-9]$/g);
        /**
         * Propriedade que lista opções aceitas além de núsmeros
         * @type {Array<string>}
         */
        this.specialKeys = [
            'Backspace',
            'Delete',
            'Tab',
            'End',
            'Home',
            'ArrowLeft',
            'ArrowRight'
        ];
    }
    /**
     * Metodo executado para os evento KeyDown do teclado executa verificação do valor digitado
     * @param {KeyboardEvent} event
     * @returns void
     */
    onKeyDown(event) {
        const current = this.el.nativeElement.value;
        const next = current.concat(event.key);
        if (this.specialKeys.indexOf(event.key) !== -1) {
            return;
        }
        if (next && String(next).match(this.regex)) {
            event.preventDefault();
        }
    }
};
OnlyNumbersDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    HostListener('keydown', ['$event'])
], OnlyNumbersDirective.prototype, "onKeyDown", null);
OnlyNumbersDirective = __decorate([
    Directive({
        selector: 'input[onlyNumbers]'
    })
], OnlyNumbersDirective);

/**
 * DIRECTIVES constant
 * @constant
 */
const DIRECTIVES = [
    OnlyNumbersDirective,
    UnmaskDirective
];
/**
 * Expõe directivas para reuso em outras palicações
 * @module
 */
let DirectivesModule = class DirectivesModule {
};
DirectivesModule = __decorate([
    NgModule({
        declarations: DIRECTIVES,
        exports: DIRECTIVES
    })
], DirectivesModule);

var FormNotificationType;
(function (FormNotificationType) {
    FormNotificationType[FormNotificationType["CLEAN"] = 0] = "CLEAN";
    FormNotificationType[FormNotificationType["FIELD"] = 1] = "FIELD";
})(FormNotificationType || (FormNotificationType = {}));
/**
 * Class modelo para validação de formulários
 * @class
 */
class FormNotification {
    /**
     * Metodo construtor para validação de formulários
     * @param {string} form
     * @param {FormNotificationType} type
     */
    constructor(form, type) {
        this.form = form;
        this.type = type;
    }
}

/**
 * Class modelo para validação de campos de formulários
 * @class
 */
class FieldFormNotification extends FormNotification {
    /**
     * Método construtor para validação de campos de formulários
     * @param {string} form
     * @param {string} field
     * @param {string} message
     */
    constructor(form, field, message) {
        super(form, FormNotificationType.FIELD);
        this.field = field;
        this.message = message;
    }
}

/**
 * Serviço ṕara tratar notificações em formulários
 * @class
 */
let FormNotificationService = class FormNotificationService {
    constructor() {
        /**
         * @type {Subject<FormNotification>()}
         */
        this.formNotifications = new Subject();
    }
    /**
     * Método para criação de inscrição de campos presentes nos formulários
     * @param {string} field
     * @returns Observable<ResponseHandle>
     */
    notifications(form, field) {
        return this.formNotifications.pipe(filter((violation) => {
            return (!form || violation.form === form) && (violation.type === FormNotificationType.CLEAN || (violation instanceof FieldFormNotification &&
                violation.field === field));
        }));
    }
    notify(notification) {
        this.formNotifications.next(notification);
    }
};
FormNotificationService.ɵprov = ɵɵdefineInjectable({ factory: function FormNotificationService_Factory() { return new FormNotificationService(); }, token: FormNotificationService, providedIn: "root" });
FormNotificationService = __decorate([
    Injectable({
        providedIn: 'root',
    })
], FormNotificationService);

/**
 * Provedor de error para criação de erros de notificação.
 * @class
 */
let FormNotificationErrorProvider = class FormNotificationErrorProvider {
    /**
     * Método construtor
     * @param {FormtNotificationService} formNotificationService
     * @constructor
     */
    constructor(formNotificationService) {
        this.formNotificationService = formNotificationService;
    }
    /**
     * Método responsável pela identificação de erros
     * @public
     * @param {Error | HttpErrorResponse} error
     * @returns Boolean
     */
    shouldHandle(error) {
        return error instanceof HttpErrorResponse &&
            error.headers.get('Content-Type') === 'application/problem+json' &&
            error.error && (error.error.violations || error.error.fieldErrors);
    }
    /**
     * Método para emissão de erros
     * @public
     * @param {HttpErrorResponse} error
     * @returns void
     */
    handle(error) {
        if (error.error.violations) {
            this.violation(error.url, error.error.violations);
        }
        if (error.error.fieldErrors) {
            this.violation(error.url, error.error.fieldErrors);
        }
    }
    /**
     * Método iteração de violações e emissão de erros
     * @param values
     */
    violation(form, values) {
        values.forEach(violation => this.formNotificationService.notify(new FieldFormNotification(form, violation.field, violation.message)));
    }
};
FormNotificationErrorProvider.ctorParameters = () => [
    { type: FormNotificationService }
];
FormNotificationErrorProvider.ɵprov = ɵɵdefineInjectable({ factory: function FormNotificationErrorProvider_Factory() { return new FormNotificationErrorProvider(ɵɵinject(FormNotificationService)); }, token: FormNotificationErrorProvider, providedIn: "root" });
FormNotificationErrorProvider = __decorate([
    Injectable({
        providedIn: 'root',
    })
], FormNotificationErrorProvider);

/**
 * Class modelo para limpeza de validação de formulários
 * @class
 */
class CleanFormNotification extends FormNotification {
    /**
     * Método construtor para limpeza de validação de formulários
     * @param {string} form
     */
    constructor(form) {
        super(form, FormNotificationType.CLEAN);
    }
}

/**
 * Implementação de classe para interceptar e tratar requisições http/https
 * @class
 */
let FormNotificationInterceptor = class FormNotificationInterceptor {
    /**
     * Método construtor
     * @constructor
     * @param {AbstractAuthentication} auth
     */
    constructor(formNotificationService) {
        this.formNotificationService = formNotificationService;
    }
    /**
     * Método responsável por interceptar requisições HTTP/HTTPS
     * @public
     * @param {HttpRequest<any>} request
     * @param {HttpHandler} next
     * @returns Observable<HttpEvent<any>>
     */
    intercept(request, next) {
        this.formNotificationService
            .notify(new CleanFormNotification(request.url));
        return next.handle(request);
    }
};
FormNotificationInterceptor.ctorParameters = () => [
    { type: FormNotificationService }
];
FormNotificationInterceptor.ɵprov = ɵɵdefineInjectable({ factory: function FormNotificationInterceptor_Factory() { return new FormNotificationInterceptor(ɵɵinject(FormNotificationService)); }, token: FormNotificationInterceptor, providedIn: "root" });
FormNotificationInterceptor = __decorate([
    Injectable({
        providedIn: 'root',
    })
], FormNotificationInterceptor);

let FormNotificationComponentSuperclass = class FormNotificationComponentSuperclass {
    /**
     * Metodo construtor responsavel por carregar o serviço de validação
     * @param formNotificationService
     */
    constructor(formNotificationService) {
        this.formNotificationService = formNotificationService;
    }
    /**
     * Metodo Inicial para subscrição no endpoint responsável por validar o formulário
     */
    ngOnInit() {
        this.subscription = this.formNotificationService
            .notifications(this.form, this.name)
            .subscribe((notification) => {
            if (notification instanceof FieldFormNotification) {
                this.message = notification.message;
            }
            else {
                this.message = null;
            }
        });
    }
    /**
     * Metodo responsavel por realizar a saida das subscrições do endpont de validação
     */
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
};
FormNotificationComponentSuperclass.ctorParameters = () => [
    { type: FormNotificationService }
];
__decorate([
    Input()
], FormNotificationComponentSuperclass.prototype, "name", void 0);
__decorate([
    Input()
], FormNotificationComponentSuperclass.prototype, "form", void 0);
FormNotificationComponentSuperclass = __decorate([
    Directive({
        selector: 'form-notification-component-superclass'
    })
], FormNotificationComponentSuperclass);

/**
 * Módulo para adicionar funcionalidade de notificação de erros de formulários.
 * @module
 */
let FormNotificationBaseModule = class FormNotificationBaseModule {
};
FormNotificationBaseModule = __decorate([
    NgModule({
        imports: [
            CommonModule
        ],
        declarations: [FormNotificationComponentSuperclass],
        exports: [FormNotificationComponentSuperclass],
        providers: [
            FormNotificationService,
            {
                provide: ErrorProvider,
                useClass: FormNotificationErrorProvider,
                multi: true,
            },
            {
                provide: HTTP_INTERCEPTORS,
                useClass: FormNotificationInterceptor,
                multi: true,
            },
        ],
    })
], FormNotificationBaseModule);

/**
 * Class provider para definição básica de tratamento de erros de formulários
 * @class
 */
class FormNotificationProvider extends ApplicationProblemType {
    /**
     * Metodo construtor para validação de formulários
     * @param {string} type
     * @param {string} title
     * @param {string} detail
     * @param {Number} status
     * @param {string} instance
     * @param {Array<string>} stacktrace
     * @param {ApplicationProblemType} cause
     * @param {FormViolation} violations
     */
    constructor(type, title, detail, status, instance, stacktrace, cause, violations) {
        super(type, title, detail, status, instance, stacktrace, cause);
        this.violations = violations;
    }
}

/**
 * Use as the superclass for anything managed by angular's dependency injection for care-free use of `subscribeTo()`. It simply calls `unsubscribe()` during `ngOnDestroy()`. If you override `ngOnDestroy()` in your subclass, be sure to invoke the super implementation.
 *
 * ```ts
 * @Injectable()
 * // or @Component() (also consider DirectiveSuperclass)
 * // or @Directive() (also consider DirectiveSuperclass)
 * // or @Pipe()
 * class MyThing extends InjectableSuperclass {
 *   constructor(somethingObservable: Observable) {
 *     super();
 *     this.subscribeTo(somethingObservable);
 *   }
 *
 *   ngOnDestroy() {
 *     // if you override ngOnDestroy, be sure to call this too
 *     super.ngOnDestroy();
 *   }
 * }
 * ```
 */
class InjectableSuperclass {
    constructor() {
        this.subscriptions = new Subscription();
        this.destructionSubject = new Subject();
        this.destruction$ = this.destructionSubject.asObservable();
    }
    subscribeTo(observable, next, error, complete) {
        this.subscriptions.add(observable.subscribe(this.bind(next), this.bind(error), this.bind(complete)));
    }
    unsubscribe() {
        this.subscriptions.unsubscribe();
        this.subscriptions = new Subscription();
    }
    bind(fn) {
        return fn === null || fn === void 0 ? void 0 : fn.bind(this);
    }
    ngOnDestroy() {
        this.unsubscribe();
        this.destructionSubject.next();
        this.destructionSubject.complete();
    }
}

/**
 * Extend this when creating a directive (including a component, which is a kind of directive) to gain access to the helpers demonstrated below. **Warning:** You _must_ include a constructor in your subclass.
 *
 * ```ts
 * @Component({
 *   selector: "s-color-text",
 *   template: `
 *     <span [style.background]="color">{{ color }}</span>
 *   `,
 *   // note that `bindToInstance()` works even with OnPush change detection
 *   changeDetection: ChangeDetectionStrategy.OnPush,
 * })
 *  class ColorTextComponent extends DirectiveSuperclass {
 *   @Input() prefix?: string;
 *   @Input() prefix2?: string;
 *   color!: string;
 *
 *   // Even if you don't need extra arguments injector, you must still include a constructor. It is required for angular to provide `Injector`.
 *   constructor(
 *     @Inject("color$") color$: Observable<string>,
 *     injector: Injector,
 *   ) {
 *     super(injector);
 *
 *     // combine everything to calculate `color` and keep it up to date
 *     this.bindToInstance(
 *       "color",
 *       combineLatest(
 *         this.getInput$("prefix"),
 *         this.getInput$("prefix2"),
 *         color$,
 *       ).pipe(map((parts) => parts.filter((p) => p).join(""))),
 *     );
 *   }
 * }
 * ```
 */
class DirectiveSuperclass extends InjectableSuperclass {
    constructor(injector) {
        super();
        /**
         *  Emits the set of `@Input()` property names that change during each call to `ngOnChanges()`.
         */
        this.inputChanges$ = new Subject();
        this.changeDetectorRef = injector.get(ChangeDetectorRef);
    }
    ngOnChanges(changes) {
        this.inputChanges$.next(new Set(Object.getOwnPropertyNames(changes)));
    }
    /**
     * @return an observable of the values for one of this directive's `@Input()` properties
     */
    getInput$(key) {
        return this.inputChanges$.pipe(filter((keys) => keys.has(key)), startWith(undefined), map(() => this[key]));
    }
    /**
     * Binds an observable to one of this directive's instance variables. When the observable emits the instance variable will be updated, and change detection will be triggered to propagate any changes. Use this an an alternative to repeating `| async` multiple times in your template.
     */
    bindToInstance(key, value$) {
        this.subscribeTo(value$, (value) => {
            this[key] = value;
            this.changeDetectorRef.markForCheck();
        });
    }
}

function noop() { }
;
/**
 * Use in the `providers` of a component that implements `ControlValueAccessor` to reduce some boilerplate.
 *
 * ```ts
 * @Component({ providers: [provideValueAccessor(MyFormControl)] }
 * class MyFormControl extends BaseFormControl {
 *   // ...
 * }
 * ```
 */
function provideValueAccessor(type) {
    return {
        provide: NG_VALUE_ACCESSOR,
        useExisting: type,
        multi: true,
    };
}
/**
 * Extend this when creating a form control to reduce some boilerplate. **Warning:** You _must_ include a constructor in your subclass.
 *
 * This example allows 2-way binding to a number via `[(ngModel)]`, `[formControl]`, or any other technique that leverages the `ControlValueAccessor` interface.
 * ```ts
 * @Component({
 *   template: `
 *     <button (click)="increment()" [disabled]="isDisabled">{{ counter }}</button>
 *   `,
 *   providers: [provideValueAccessor(CounterComponent)],
 * })
 * class CounterComponent extends FormControlSuperclass<number> {
 *   counter = 0;
 *
 *   // This looks unnecessary, but is required for Angular to provide `Injector`
 *   constructor(injector: Injector) {
 *     super(injector);
 *   }
 *
 *   handleIncomingValue(value: number) {
 *     this.counter = value;
 *   }
 *
 *   increment() {
 *     this.emitOutgoingValue(++this.counter);
 *     this.onTouched();
 *   }
 * }
 * ```
 */
class FormControlSuperclass extends DirectiveSuperclass {
    constructor() {
        super(...arguments);
        /** Call this to emit a new value when it changes. */
        this.emitOutgoingValue = noop;
        /** Call this to "commit" a change, traditionally done e.g. on blur. */
        this.onTouched = noop;
        /** You can bind to this in your template as needed. */
        this.isDisabled = false;
    }
    /** Called as angular propagates value changes to this `ControlValueAccessor`. You normally do not need to use it. */
    writeValue(value) {
        this.handleIncomingValue(value);
        this.changeDetectorRef.markForCheck();
    }
    /** Called as angular sets up the binding to this `ControlValueAccessor`. You normally do not need to use it. */
    registerOnChange(fn) {
        this.emitOutgoingValue = fn;
    }
    /** Called as angular sets up the binding to this `ControlValueAccessor`. You normally do not need to use it. */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /** Called as angular propagates disabled changes to this `ControlValueAccessor`. You normally do not need to use it. */
    setDisabledState(isDisabled) {
        this.isDisabled = isDisabled;
        this.changeDetectorRef.markForCheck();
    }
}

class WrappedFormControlSuperclass extends FormControlSuperclass {
    constructor(injector) {
        super(injector);
        this.formControl = new FormControl();
        this.subscribeTo(this.formControl.valueChanges, (value) => {
            this.emitOutgoingValue(this.innerToOuter(value));
        });
        this.formControl.markAsTouched = () => {
            this.onTouched();
        };
    }
    /** Called as angular propagates values changes to this `ControlValueAccessor`. You normally do not need to use it. */
    handleIncomingValue(value) {
        this.formControl.setValue(this.outerToInner(value), { emitEvent: false });
    }
    /** Called as angular propagates disabled changes to this `ControlValueAccessor`. You normally do not need to use it. */
    setDisabledState(isDisabled) {
        if (isDisabled) {
            this.formControl.disable({ emitEvent: false });
        }
        else {
            this.formControl.enable({ emitEvent: false });
        }
        super.setDisabledState(this.isDisabled);
    }
    /** Override this to modify a value coming from the outside to the format needed within this component. */
    outerToInner(value) {
        return value;
    }
    /** Override this to modify a value coming from within this component to the format expected on the outside. */
    innerToOuter(value) {
        return value;
    }
}

/*
 * Public API Surface of angular-base
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AUTH_CONFIG, AccessbilityModule, AccessbilityService, ApplicationProblemType, AuthGuard, Authentication, AuthenticationService, Authorization, AuthorizationService, BlockUiInterceptor, BlockUiService, CepPipe, CleanFormNotification, ClipboardDirective, ClipboardModule, ClipboardService, CnpjPipe, CommonMaskModule, CommonMaskService, CpfPipe, DirectivesModule, ErrorModule, ErrorProvider, ErrorService, ErrorStackProviderService, ErrorStackService, FieldFormNotification, FormControlSuperclass, FormNotification, FormNotificationBaseModule, FormNotificationComponentSuperclass, FormNotificationErrorProvider, FormNotificationProvider, FormNotificationService, FormNotificationType, GENERIC_ERRORS, HasRoleDirective, HideWhileLoginComponent, HttpApplicationProblemErrorService, HttpGenericErrorService, HttpGenericErrorType, JWTAuthInterceptor, JWTTokenService, LimitPipe, LoginSuccessComponent, LogoutDirective, NotAuthenticatedErrorProvider, NotificationProvider, NotificationService, OnlyNumbersDirective, PipeModule, RegexPipe, SecurityModule, Token, UnmaskDirective, UserDirective, VersionTagComponent, VersionTagModule, WrappedFormControlSuperclass, bootstrapSecurity, isAuthenticated, noop, provideValueAccessor, redirect, FormNotificationInterceptor as ɵa, DirectiveSuperclass as ɵb, InjectableSuperclass as ɵc };
//# sourceMappingURL=nuvem-angular-base.js.map
