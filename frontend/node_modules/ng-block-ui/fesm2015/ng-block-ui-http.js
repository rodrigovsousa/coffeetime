import { HTTP_INTERCEPTORS } from '@angular/common/http';
import { Injectable, NgModule, InjectionToken } from '@angular/core';
import { finalize } from 'rxjs/operators';
import { BlockUIService, BLOCKUI_DEFAULT, BlockUIModule } from 'ng-block-ui';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from 'ng-block-ui';
class BlockUIHttpSettings {
    constructor() {
        this.settings = {};
    }
}
BlockUIHttpSettings.ɵfac = function BlockUIHttpSettings_Factory(t) { return new (t || BlockUIHttpSettings)(); };
BlockUIHttpSettings.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: BlockUIHttpSettings, factory: BlockUIHttpSettings.ɵfac });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BlockUIHttpSettings, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class BlockUIInterceptor {
    /**
     * @param {?} blockUIService
     * @param {?} blockUIHttpSettings
     */
    constructor(blockUIService, blockUIHttpSettings) {
        this.blockUIService = blockUIService;
        this.blockUIHttpSettings = blockUIHttpSettings;
        this.activeHttpRequests = 0;
    }
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    intercept(request, next) {
        let /** @type {?} */ active = false;
        if (this.shouldBlock(request)) {
            active = true;
            this.activeHttpRequests++;
            this.blockUIService.start(BLOCKUI_DEFAULT);
        }
        return next.handle(request)
            .pipe(finalize(() => {
            if (this.shouldBlock(request)) {
                this.activeHttpRequests--;
                const { blockAllRequestsInProgress } = this.blockUIHttpSettings.settings;
                let /** @type {?} */ stopBlockUI = false;
                if (!!blockAllRequestsInProgress && this.activeHttpRequests <= 0) {
                    this.activeHttpRequests = 0;
                    stopBlockUI = true;
                }
                else if (active) {
                    stopBlockUI = true;
                }
                if (stopBlockUI) {
                    const /** @type {?} */ method = blockAllRequestsInProgress ? 'stop' : 'reset';
                    this.blockUIService[method](BLOCKUI_DEFAULT);
                }
            }
        }));
    }
    /**
     * @param {?} request
     * @return {?}
     */
    shouldBlock(request) {
        const { method, urlWithParams } = request;
        const { settings } = this.blockUIHttpSettings;
        const /** @type {?} */ requestFilters = settings.requestFilters || [];
        return !requestFilters.some((f) => {
            if (f && f.method && f.url) {
                return f.method.toUpperCase() === method && f.url.test(urlWithParams);
            }
            else if (typeof f === 'function') {
                return f(request);
            }
            return f.test(urlWithParams);
        });
    }
}
BlockUIInterceptor.ɵfac = function BlockUIInterceptor_Factory(t) { return new (t || BlockUIInterceptor)(ɵngcc0.ɵɵinject(ɵngcc1.BlockUIService), ɵngcc0.ɵɵinject(BlockUIHttpSettings)); };
BlockUIInterceptor.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: BlockUIInterceptor, factory: BlockUIInterceptor.ɵfac });
/** @nocollapse */
BlockUIInterceptor.ctorParameters = () => [
    { type: BlockUIService },
    { type: BlockUIHttpSettings }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BlockUIInterceptor, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.BlockUIService }, { type: BlockUIHttpSettings }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Needed for AOT compiling
const /** @type {?} */ BlockUIHttpModuleSettings = new InjectionToken('BlockUIHttpModuleSettings');
/**
 * @param {?} settings
 * @return {?}
 */
function provideSettingsInstance(settings) {
    return { settings };
}
class BlockUIHttpModule {
    /**
     * @param {?=} settings
     * @return {?}
     */
    static forRoot(settings = {}) {
        return {
            ngModule: BlockUIHttpModule,
            providers: [
                {
                    provide: BlockUIHttpModuleSettings,
                    useValue: settings
                },
                {
                    provide: BlockUIHttpSettings,
                    useFactory: provideSettingsInstance,
                    deps: [BlockUIHttpModuleSettings]
                },
                {
                    provide: HTTP_INTERCEPTORS,
                    useClass: BlockUIInterceptor,
                    multi: true
                }
            ]
        };
    }
}
BlockUIHttpModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: BlockUIHttpModule });
BlockUIHttpModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function BlockUIHttpModule_Factory(t) { return new (t || BlockUIHttpModule)(); }, imports: [[BlockUIModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(BlockUIHttpModule, { imports: function () { return [BlockUIModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BlockUIHttpModule, [{
        type: NgModule,
        args: [{
                imports: [BlockUIModule]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { BlockUIHttpModule, BlockUIHttpSettings as ɵc, BlockUIInterceptor as ɵd, BlockUIHttpModuleSettings as ɵa, provideSettingsInstance as ɵb };

//# sourceMappingURL=ng-block-ui-http.js.map